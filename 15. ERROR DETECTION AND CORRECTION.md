មានហេតុផលជាច្រើនដូចជា noise, cross-talk ជាដើម ដែលអាចធ្វើឱ្យ data ត្រូវបានខូចក្នុងពេលធ្វើការបញ្ជូន។ upper layers ធ្វើការលើទិដ្ឋភាពទូទៅនៃ network architecture ហើយមិនដឹងពីការដំណើរការ hardware data ជាក់ស្តែងទេ។ ដូច្នេះ upper layers រំពឹងថានឹងមានការបញ្ជូនដោយគ្មានកំហុសរវាងប្រព័ន្ធទាំងនេះ។ applications ភាគច្រើននឹងមិនដំណើរការត្រឹមត្រូវទេប្រសិនបើទទួលបាន data ខុស។ applications ដូចជាសម្លេងនិងវីដេអូប្រហែលជាមិនរងផលប៉ះពាល់ទេ ហើយនៅតែអាចដំណើរការបានល្អជាមួយនឹងកំហុសមួយចំនួន។

Data-link layer ប្រើប្រាស់យន្តការត្រួតពិនិត្យកំហុសមួយចំនួនដើម្បីធានាថា frames (data bit streams) ត្រូវបានបញ្ជូនដោយមានកម្រិតភាពត្រឹមត្រូវជាក់លាក់។ ប៉ុន្តេដើម្បីយល់ពីរបៀបគ្រប់គ្រងកំហុស វាសំខាន់ត្រូវដឹងថាតើមានប្រភេទកំហុសអ្វីខ្លះដែលអាចកើតឡើង។

# Types of Errors
---
អាចមានកំហុសបីប្រភេទ៖

## Single bit error

![[Pasted image 20250201200258.png]]

នៅក្នុង frame មានតែ bit មួយប៉ុណ្ណោះ នៅទីណាក៏ដោយ ដែលខូច។

## Multiple bits error

![[Pasted image 20250201200322.png]]

Frame ត្រូវបានទទួលដោយមាន bits ច្រើនជាងមួយស្ថិតក្នុងស្ថានភាពខូច។

## Burst error

![[Pasted image 20250201200336.png]]

Frame មាន bits ជាប់ៗគ្នាច្រើនជាងមួយដែលខូច។

យន្តការត្រួតពិនិត្យកំហុសអាចមានវិធីពីរ៖
- Error detection
- Error correction

# Error Detection
---
កំហុសនៅក្នុង frames ដែលបានទទួលត្រូវបានរកឃើញតាមរយៈ Parity Check និង Cyclic Redundancy Check (CRC)។ ក្នុងករណីទាំងពីរ bits បន្ថែមមួយចំនួនត្រូវបានផ្ញើជាមួយ data ពិតប្រាកដដើម្បីបញ្ជាក់ថា bits ដែលបានទទួលនៅចុងម្ខាងទៀតដូចគ្នានឹងអ្វីដែលបានផ្ញើ។ ប្រសិនបើការត្រួតពិនិត្យនៅផ្នែកទទួលបរាជ័យ bits ត្រូវបានចាត់ទុកថាខូច។

## Parity Check
bit បន្ថែមមួយត្រូវបានផ្ញើជាមួយនឹង bits ដើមដើម្បីធ្វើឱ្យចំនួននៃ 1s ជាលេខគូក្នុងករណី even parity ឬលេខសេសក្នុងករណី odd parity។

អ្នកផ្ញើនៅពេលបង្កើត frame រាប់ចំនួន 1s នៅក្នុងវា។ ឧទាហរណ៍ ប្រសិនបើប្រើ even parity ហើយចំនួន 1s គឺជាលេខគូ នោះ bit ដែលមានតម្លៃ 0 ត្រូវបានបន្ថែម។ តាមវិធីនេះចំនួន 1s នៅតែជាលេខគូ។ ប្រសិនបើចំនួន 1s គឺជាលេខសេស ដើម្បីធ្វើឱ្យវាទៅជាលេខគូ bit ដែលមានតម្លៃ 1 ត្រូវបានបន្ថែម។

![[Pasted image 20250201200510.png]]

អ្នកទទួលគ្រាន់តែរាប់ចំនួន 1s នៅក្នុង frame។ ប្រសិនបើចំនួន 1s គឺជាលេខគូ ហើយ even parity ត្រូវបានប្រើ frame ត្រូវបានចាត់ទុកថាមិនខូច ហើយត្រូវបានទទួលយក។ ប្រសិនបើចំនួន 1s គឺជាលេខសេស ហើយ odd parity ត្រូវបានប្រើ frame នៅតែមិនខូច។

ប្រសិនបើមាន bit តែមួយត្រឡប់ក្នុង frame អ្នកទទួលអាចរកឃើញវាដោយរាប់ចំនួន 1s។ ប៉ុន្តែនៅពេលដែល bits ច្រើនជាងមួយមានកំហុស វាពិបាកណាស់សម្រាប់អ្នកទទួលក្នុងការរកឃើញកំហុស។

## Cyclic Redundancy Check (CRC)
CRC គឺជាវិធីសាស្ត្រផ្សេងដើម្បីពិនិត្យមើលថាតើ frame ដែលបានទទួលមាន data ត្រឹមត្រូវឬទេ។ បច្ចេកទេសនេះពាក់ព័ន្ធនឹងការចែក binary នៃ data bits ដែលត្រូវផ្ញើ។ ភាគបែងត្រូវបានបង្កើតដោយប្រើ polynomials។ អ្នកផ្ញើធ្វើប្រតិបត្តិការចែកលើ bits ដែលត្រូវផ្ញើ ហើយគណនាសំណល់។ មុនពេលផ្ញើ bits ពិតប្រាកដ អ្នកផ្ញើបន្ថែមសំណល់នៅចុងបញ្ចប់នៃ bits ពិតប្រាកដ។ data bits ពិតប្រាកដបូកនឹងសំណល់ត្រូវបានហៅថា codeword។ អ្នកផ្ញើបញ្ជូន data នេះទៅកាន់អ្នកទទួល។

![[Pasted image 20250201200553.png]]

នៅចុងម្ខាងទៀត receiver អនុវត្តប្រមាណវិធីចែកលើ codewords ដោយប្រើ CRC divisor ដូចគ្នា។ ប្រសិនបើសំណល់មានសុទ្ធតែលេខសូន្យ នោះ data bits ត្រូវបានទទួលយក បើមិនដូច្នោះទេ វាត្រូវបានចាត់ទុកថាមានការខូចខាតទិន្នន័យក្នុងពេលបញ្ជូន។

# Error Correction
---
ក្នុងពិភពឌីជីថល error correction អាចធ្វើបានតាមពីររបៀប៖

## Backward Error Correction

នៅពេលដែល receiver រកឃើញកំហុសនៅក្នុងទិន្នន័យដែលបានទទួល វាស្នើទៅ sender ឱ្យបញ្ជូនទិន្នន័យម្តងទៀត។

## Forward Error Correction

នៅពេលដែល receiver រកឃើញកំហុសមួយចំនួននៅក្នុងទិន្នន័យដែលបានទទួល វាអនុវត្ត error-correction code ដែលអាចជួយស្តារនិងកែតម្រូវកំហុសមួយចំនួន។

របៀបទីមួយ Backward Error Correction គឺសាមញ្ញហើយអាចប្រើប្រាស់បានប្រសិទ្ធភាពតែនៅពេលដែលការបញ្ជូនឡើងវិញមិនថ្លៃពេកប៉ុណ្ណោះ។ ឧទាហរណ៍ fiber optics។ ប៉ុន្តែក្នុងករណីការបញ្ជូនតាមរលកធាតុអាកាស ការបញ្ជូនឡើងវិញអាចមានតម្លៃខ្ពស់។ ក្នុងករណីនេះ Forward Error Correction ត្រូវបានប្រើប្រាស់។

ដើម្បីកែកំហុសក្នុង data frame, receiver ត្រូវដឹងច្បាស់ថាប៊ីតណាមួយក្នុង frame គឺខូច។ ដើម្បីរកប៊ីតដែលមានកំហុស redundant bits ត្រូវបានប្រើជា parity bits សម្រាប់រកកំហុស។ ឧទាហរណ៍ យើងយក ASCII words (7 bits data) បន្ទាប់មកអាចមាន 8 ប្រភេទនៃព័ត៌មាន។ អ្វីដែលយើងត្រូវការគឺ៖ ទីមួយ parity bit មួយដើម្បីប្រាប់ថាមានកំហុសមួយ។

សម្រាប់ m data bits, r redundant bits ត្រូវបានប្រើប្រាស់។ r bits អាចផ្តល់ 2r combinations នៃព័ត៌មាន។ នៅក្នុង m+r bit codeword មានលទ្ធភាពដែល r bits ខ្លួនវាអាចខូច។ ដូច្នេះចំនួននៃ bits ដែលត្រូវប្រើប្រាស់ត្រូវតែផ្តល់ព័ត៌មានអំពីទីតាំង m+r bits បូកនឹងព័ត៌មានគ្មានកំហុស ពោលគឺ n=r+1។
