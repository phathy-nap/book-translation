សម្រាប់ព័ត៌មានបន្ថែម សូមចូលទៅកាន់: https://github.com/phathy-nap/book-translation

# **1. OVERVIEW**

ប្រព័ន្ធដែលមានកុំព្យូទ័រចងភ្ជាប់គ្នា និងឧបករណ៍បច្ចេកវិទ្យាដែលត្រូវបានកុំព្យូទ័របញ្ជាពីចម្ងាយ ដូចជា **printers** ត្រូវបានគេហៅថា **computer network**។ ការចងភ្ជាប់នេះអាចធ្វើឱ្យកុំព្យូទ័រចែករំលែកព័ត៌មានគ្នាទៅវិញទៅមកបាន។ កុំព្យូទ័រអាចភ្ជាប់គ្នាតាមរយៈប្រព័ន្ធខ្សែឬប្រព័ន្ធឥតខ្សែ។

# Classification of Computer Networks
---
**Computer networks** ត្រូវបានបែងចែកទៅតាមកត្តាជាច្រើន។ កត្តាទាំងនេះរួមមាន៖

- **Geographical span**
- **Inter-connectivity**
- **Administration**
- **Architecture**

---

# Geographical Span
---
ជាធម្មតា **network** ត្រូវបានចាត់ទុកជាប្រភេទដូចខាងក្រោម៖

- វាអាចត្រូវបានបណ្តាញនៅលើតុរបស់អ្នក ដោយប្រើឧបករណ៍ **Bluetooth enabled devices** ដែលមានចម្ងាយមិនលើសពីមួយចំនួនម៉ែត្រ។
- វាអាចត្រូវបានបណ្តាញនៅក្នុងអគារមួយទាំងមូល ដោយប្រើឧបករណ៍ចងភ្ជាប់ដើម្បីភ្ជាប់ជាន់ទាំងអស់។
- វាអាចត្រូវបានបណ្តាញនៅក្នុងទីក្រុងមួយទាំងមូល។
- វាអាចត្រូវបានបណ្តាញនៅក្នុងច្រើនទីក្រុង ឬខេត្ត។
- វាអាចជាបណ្តាញមួយដែលគ្របដណ្តប់ពិភពលោកទាំងមូល។

---

# Inter-Connectivity
---
សមាសភាគនៃ **network** អាចត្រូវបានភ្ជាប់គ្នាដោយវិធីផ្សេងៗគ្នា។ ការភ្ជាប់នេះអាចមានន័យថា **logically**, **physically**, ឬទាំងពីរនេះ។ 

- ឧបករណ៍ទាំងអស់អាចភ្ជាប់គ្នាជាមួយឧបករណ៍ផ្សេងទៀតនៅលើ **network** ដើម្បីបង្កើត **network mesh**។
- ឧបករណ៍ទាំងអស់អាចភ្ជាប់ទៅប្រព័ន្ធមធ្យមតែមួយ ប៉ុន្តែមានការបែងចែកតាមភូមិសាស្ត្រ ដូចជា **bus-like structure**។
- ឧបករណ៍នីមួយៗត្រូវបានភ្ជាប់ទៅឆ្វេង និងស្តាំតាមលំដាប់ ដើម្បីបង្កើត **linear structure**។
- គ្រប់ឧបករណ៍ត្រូវបានភ្ជាប់ជាមួយឧបករណ៍តែមួយ ដើម្បីបង្កើតរចនាសម្ព័ន្ធដូចផ្កាយ។
- គ្រប់ឧបករណ៍ត្រូវបានភ្ជាប់ដោយចៃដន្យ ដោយប្រើវិធីសាស្រ្តមុនៗទាំងអស់ ដើម្បីភ្ជាប់គ្នា បង្កើតរចនាសម្ព័ន្ធ **hybrid**។

# Administration
---
ពីទស្សនៈរបស់អ្នកគ្រប់គ្រង **network** អាចជា **private network** ដែលជាកម្មសិទ្ធិរបស់ប្រព័ន្ធឯករាជ្យតែមួយ ហើយមិនអាចចូលប្រើបាននៅខាងក្រៅដែនដីរបស់វាឬដែនដីលូជិក។ **Network** អាចជាសាធារណៈ ដែលអាចចូលប្រើបានដោយអ្នកទាំងអស់។

# Network Architecture
---
បណ្តាញកុំព្យូទ័រអាចបែងចែកទៅជាប្រភេទផ្សេងៗដូចជា **Client-Server**, **peer-to-peer** ឬ **hybrid** ដោយផ្អែកលើរចនាសម្ព័ន្ធរបស់វា។

- អាចមានប្រព័ន្ធមួយឬច្រើនដំណើរការជា **Server**។ ប្រព័ន្ធផ្សេងទៀតដែលជា **Client** ស្នើសុំឱ្យ **Server** បំពេញសំណើ។ **Server** ទទួលសំណើ និងដំណើរការសំណើនៅក្នុងនាម **Client**។
- ប្រព័ន្ធពីរអាចត្រូវបានភ្ជាប់ជាប្រភេទ **Point-to-Point** ឬភ្ជាប់ពីក្រោយទៅក្រោយ។ ពួកវាស្ថិតនៅលើកម្រិតដូចគ្នា ហើយត្រូវបានគេហៅថា **peers**។
- អាចមាន **hybrid network** ដែលរួមបញ្ចូលរចនាសម្ព័ន្ធបណ្តាញពីរប្រភេទខាងលើ។

# Network Applications
---
ប្រព័ន្ធកុំព្យូទ័រ និងឧបករណ៍បន្ថែមត្រូវបានភ្ជាប់ដើម្បីបង្កើត **network**។ វាបានផ្តល់អត្ថប្រយោជន៍ជាច្រើន៖

- ការចែករំលែកធនធាន ដូចជា **printers** និងឧបករណ៍ផ្ទុកទិន្នន័យ
- ការផ្លាស់ប្តូរព័ត៌មានតាមរយៈ **e-Mails** និង **FTP**
- ការចែករំលែកព័ត៌មានតាមរយៈ **Web** ឬ **Internet**
- ការប្រាស្រ័យទាក់ទងជាមួយអ្នកប្រើផ្សេងទៀតតាម **dynamic web pages**
- **IP phones**
- ការប្រជុំតាមវីដេអូ
- ការគណនាដោយសហការ
- ការផ្ញើសារបន្ទាន់

# **2. TYPES OF COMPUTER NETWORKS**

ជាទូទៅ បណ្តាញត្រូវបានបែងចែកដោយផ្អែកលើលក្ខណៈភូមិសាស្ត្រ។ បណ្តាញអាចមានទំហំតូចបំផុត ដូចជាគម្លាតរវាងទូរស័ព្ទចល័តរបស់អ្នក និងកាស Bluetooth របស់វា ហើយអាចមានទំហំធំបំផុតដូចជាបណ្តាញអ៊ីនធឺណិត ដែលគ្របដណ្តប់លើពិភពលោកទាំងមូល។

# Personal Area Network
---
បណ្តាញផ្ទាល់ខ្លួន (Personal Area Network - PAN) គឺជាបណ្តាញតូចបំផុត ដែលមានលក្ខណៈផ្ទាល់ខ្លួនសម្រាប់អ្នកប្រើប្រាស់។ វាអាចរួមមានឧបករណ៍ដែលមានសមត្ថភាព Bluetooth ឬឧបករណ៍ដែលមានសមត្ថភាព infra-red។ PAN មានចន្លោះសេវាកម្មរហូតដល់ 10 ម៉ែត្រ។ PAN អាចរួមមានក្តារចុច និងកណ្តុរឥតខ្សែ កាស Bluetooth ម៉ាស៊ីនបោះពុម្ពឥតខ្សែ និងឧបករណ៍បញ្ជាទូរទស្សន៍។

ឧទាហរណ៍ Piconet គឺជាបណ្តាញផ្ទាល់ខ្លួនដែលប្រើសេវា Bluetooth ដែលអាចមានឧបករណ៍រហូត
ដល់ 8 ត្រូវបានភ្ជាប់គ្នា ដោយប្រើរបៀប master-slave។

![[Pasted image 20250131172038.png|]]
# Local Area Network
---
បណ្តាញកុំព្យូទ័រដែលមានការគ្របដណ្តប់នៅក្នុងអគារមួយ និងដំណើរការក្រោមប្រព័ន្ធគ្រប់គ្រងតែមួយត្រូវបានគេហៅជាទូទៅថា បណ្តាញក្នុងតំបន់ (Local Area Network - LAN)។ ជាទូទៅ LAN គ្របដណ្តប់លើការិយាល័យស្ថាប័ន សាលារៀន សាកលវិទ្យាល័យ ឬអង្គការផ្សេងៗ។ ចំនួនប្រព័ន្ធដែលភ្ជាប់ក្នុង LAN អាចមានចាប់ពី 2 រហូតដល់ 16 លាន។ LAN គឺជាវិធីដ៏មានប្រយោជន៍មួយសម្រាប់ការចែករំលែកធនធានរវាងអ្នកប្រើប្រាស់ចុងក្រោយ។ ធនធានដូចជា Printer, File Server, Scanner និង Internet គឺងាយស្រួលក្នុងការចែករំលែករវាងកុំព្យូទ័រនានា។

![[Pasted image 20250131185538.png]]

LAN ត្រូវបានបង្កើតឡើងដោយប្រើឧបករណ៍បណ្តាញ និងឧបករណ៍ניtingដែលមានតម្លៃថោក។ វាអាចមាន Local Server សម្រាប់ផ្ទុកឯកសារ និងកម្មវិធីដែលចែករំលែកក្នុងមូលដ្ឋាន។ វាភាគច្រើនដំណើរការលើ Private IP Address ហើយមិនពាក់ព័ន្ធនឹងការនាំផ្លូវតាមអ៊ីនធឺណិតទេ។ វាដំណើរការក្រោមដែនមូលដ្ឋានផ្ទាល់ខ្លួន និងត្រូវបានគ្រប់គ្រងដោយមជ្ឈមណ្ឌល។

LAN ប្រើប្រាស់បច្ចេកវិទ្យា Ethernet ឬ Token-ring។ Ethernet គឺជាបច្ចេកវិទ្យា LAN ដែលគេប្រើប្រាស់ច្រើនបំផុត និងប្រើប្រាស់ Star Topology ខណៈដែល Token-ring កម្រឃើញមានការប្រើប្រាស់។

LAN អាចជាប្រភេទមានខ្សែ ឥតខ្សែ ឬក៏អាចមានទាំងពីរប្រភេទក្នុងពេលតែមួយ។

# Metropolitan Area Network
---
Metropolitan Area Network (MAN) ជាទូទៅពង្រីកពេញមួយទីក្រុងដូចជាបណ្តាញកែប្រែទូរទស្សន៍។ វាអាចស្ថិតក្នុងទម្រង់ជា Ethernet, Token-ring, ATM ឬ Fiber Distributed Data Interface (FDDI)។

Metro Ethernet គឺជាសេវាកម្មមួយដែលផ្តល់ដោយ ISP។ សេវាកម្មនេះអនុញ្ញាតឱ្យអ្នកប្រើប្រាស់ពង្រីក Local Area Network របស់ពួកគេ។ ឧទាហរណ៍ MAN អាចជួយស្ថាប័នមួយភ្ជាប់ការិយាល័យទាំងអស់របស់ខ្លួនក្នុងទីក្រុងមួយ។

![[Pasted image 20250131185655.png]]

Backbone នៃ MAN គឺជាខ្សែកាប្លអុបទិកដែលមានល្បឿនលឿននិងសមត្ថភាពខ្ពស់។ MAN ដំណើរការនៅចន្លោះ Local Area Network និង Wide Area Network។ MAN ផ្តល់នូវការតភ្ជាប់ឡើងលើសម្រាប់ LAN ទៅ WAN ឬ internet។

# Wide Area Network
---
ដូចដែលឈ្មោះបានបង្ហាញ Wide Area Network (WAN) គ្របដណ្តប់លើផ្ទៃដីធំទូលាយដែលអាចលាតសន្ធឹងឆ្លងកាត់ខេត្តនានា និងរហូតដល់ប្រទេសទាំងមូល។ ជាទូទៅ បណ្តាញទូរគមនាគមន៍គឺជា Wide Area Network។ បណ្តាញទាំងនេះផ្តល់នូវការតភ្ជាប់ទៅកាន់ MAN និង LAN។ ដោយសារតែបណ្តាញទាំងនេះត្រូវបានបំពាក់ដោយ backbone ដែលមានល្បឿនលឿនខ្លាំង WAN គឺជាឧបករណ៍បណ្តាញដែលមានតម្លៃថ្លៃ។

![[Pasted image 20250131185745.png]]

# Wide Area Network (WAN)
---
WAN អាចប្រើប្រាស់បច្ចេកវិទ្យាទំនើបៗដូចជា Asynchronous Transfer Mode (ATM), Frame Relay និង Synchronous Optical Network (SONET)។ WAN អាចត្រូវបានគ្រប់គ្រងដោយអ្នកគ្រប់គ្រងច្រើននាក់។

# Internetwork
---
បណ្តាញនៃបណ្តាញត្រូវបានគេហៅថា Internetwork ឬគ្រាន់តែហៅថា Internet។ វាគឺជាបណ្តាញធំបំផុតដែលមាននៅលើភពផែនដីនេះ។ Internet ភ្ជាប់ទំនាក់ទំនងស្ទើរតែគ្រប់ WAN និងអាចមានការតភ្ជាប់ទៅកាន់ LAN និងបណ្តាញតាមផ្ទះ។ Internet ប្រើប្រាស់ TCP/IP Protocol និងប្រើ IP ជា addressing protocol។ បច្ចុប្បន្ន Internet កំពុងអនុវត្តប្រើប្រាស់ IPv4។ ដោយសារតែការខ្វះខាត address spaces វាកំពុងផ្លាស់ប្តូរពី IPv4 ទៅ IPv6។

Internet អនុញ្ញាតឱ្យអ្នកប្រើប្រាស់របស់ខ្លួនចែករំលែក និងចូលប្រើប្រាស់ព័ត៌មានដ៏ច្រើនសន្ធឹកសន្ធាប់នៅទូទាំងពិភពលោក។ វាប្រើប្រាស់ WWW, FTP, សេវាកម្មអ៊ីមែល, សំឡេង និងការបញ្ជូនវីដេអូជាដើម។ នៅកម្រិតទាបបំផុត Internet ដំណើរការលើម៉ូដែល Client-Server។

Internet ប្រើប្រាស់បណ្តាញឆ្អឹងខ្នងល្បឿនលឿនដែលធ្វើពីខ្សែអុបទិក។ ដើម្បីតភ្ជាប់ទ្វីបនានា ខ្សែអុបទិកត្រូវបានដាក់ក្រោមសមុទ្រដែលយើងស្គាល់ថាជាខ្សែកាបទូរគមនាគមន៍ក្រោមទឹក។

Internet ត្រូវបានប្រើប្រាស់យ៉ាងទូលំទូលាយតាមរយៈសេវាកម្ម Web ដែលប្រើ HTML linked pages និងអាចចូលប្រើប្រាស់បានតាមរយៈកម្មវិធី Web Browsers។ នៅពេលអ្នកប្រើប្រាស់ស្នើសុំទំព័រណាមួយតាមរយៈ web browser ដែលស្ថិតនៅលើ Web Server ណាមួយនៅលើពិភពលោក Web Server ឆ្លើយតបជាមួយទំព័រ HTML ត្រឹមត្រូវ។ ការពន្យារពេលនៃការទំនាក់ទំនងគឺទាបណាស់។

Internet កំពុងបម្រើគោលបំណងជាច្រើន និងពាក់ព័ន្ធក្នុងទិដ្ឋភាពជាច្រើននៃជីវិត។ ខាងក្រោមនេះគឺជាឧទាហរណ៍មួយចំនួន៖
- គេហទំព័រ (Web sites)
- អ៊ីមែល (E-mail)
- ការផ្ញើសារភ្លាមៗ (Instant Messaging)
- ការសរសេរប្លុក (Blogging)
- បណ្តាញសង្គម (Social Media)
- ការតភ្ជាប់បណ្តាញ (Marketing)
- ការចែករំលែកធនធាន (Resource Sharing)
- ការស្តាប់និងមើលវីដេអូតាមអ៊ីនធឺណិត (Audio and Video Streaming)

# **3. NETWORK LAN TECHNOLOGIES**

ចូរយើងពិនិត្យមើលបច្ចេកវិទ្យា LAN ផ្សេងៗដោយសង្ខេប៖

# Ethernet
---
Ethernet គឺជាបច្ចេកវិទ្យា LAN ដែលត្រូវបានប្រើប្រាស់យ៉ាងទូលំទូលាយ។ បច្ចេកវិទ្យានេះត្រូវបានបង្កើតឡើងដោយ Bob Metcalfe និង D.R. Boggs នៅឆ្នាំ ១៩៧០។ វាត្រូវបានធ្វើស្តង់ដារនៅក្នុង IEEE 802.3 នៅឆ្នាំ ១៩៨០។

Ethernet ចែករំលែកមេឌៀ។ Network ដែលប្រើប្រាស់មេឌៀរួមគ្នាមានប្រូបាប៊ីលីតេខ្ពស់នៃការប៉ះទង្គិចទិន្នន័យ។ វាប្រើប្រាស់បច្ចេកវិទ្យា Carrier Sense Multi Access/Collision Detection (CSMA/CD) ដើម្បីរកឃើញការប៉ះទង្គិច។ នៅពេលមានការប៉ះទង្គិចនៅក្នុង Ethernet រាល់ host ទាំងអស់ថយក្រោយ រង់ចាំរយៈពេលចៃដន្យមួយ ហើយបន្ទាប់មកបញ្ជូនទិន្នន័យម្តងទៀត។

ឧបករណ៍ភ្ជាប់ Ethernet គឺជាកាត network interface ដែលមានអាសយដ្ឋាន MAC ៤៨-ប៊ីត។ វាជួយឱ្យឧបករណ៍ Ethernet ផ្សេងទៀតកំណត់អត្តសញ្ញាណ និងទំនាក់ទំនងជាមួយឧបករណ៍ដែលបានភ្ជាប់បណ្តាញ។

Ethernet បែបប្រពៃណីប្រើប្រាស់លក្ខណៈសម្បត្តិ 10BASE-T។ លេខ ១០ តំណាងឱ្យល្បឿន 10MBPS BASE តំណាងឱ្យ baseband និង T តំណាងឱ្យ Thick Ethernet។ 10BASE-T Ethernet ផ្តល់ល្បឿនបញ្ជូន ១០ MBPS និងប្រើខ្សែកាប coaxial ឬ Cat-5 twisted pair ជាមួយឧបករណ៍ភ្ជាប់ RJ-5។ Ethernet អនុវត្តតាមប្លង់រចនា Star ជាមួយនឹងប្រវែងកម្រិត ១០០ ម៉ែត្រ។ ឧបករណ៍ទាំងអស់ត្រូវបានភ្ជាប់ទៅ hub/switch ក្នុងទម្រង់ផ្កាយ។

# Fast-Ethernet
---
ដើម្បីគ្របដណ្តប់លើតម្រូវការនៃបច្ចេកវិទ្យាកម្មវិធី និងផ្នែករឹងដែលកំពុងលេចឡើងយ៉ាងលឿន Ethernet បានពង្រីកខ្លួនទៅជា Fast-Ethernet។ វាអាចដំណើរការលើ UTP, Optical Fiber និង wireless ផងដែរ។ វាអាចផ្តល់ល្បឿនរហូតដល់ 100MBPS។ ស្តង់ដារនេះត្រូវបានកំណត់នៅក្នុង IEEE 802.3 ដោយប្រើខ្សែ Cat-5 twisted pair។ វាប្រើបច្ចេកទេស CSMA/CD សម្រាប់ការចែករំលែកមេឌៀរវាង host Ethernet និង CSMA/CA (CA មានន័យថា Collision Avoidance) សម្រាប់បណ្តាញ Ethernet ឥតខ្សែ។

Fast Ethernet លើ fiber ត្រូវបានកំណត់ក្រោមស្តង់ដារ 100BASE-FX ដែលផ្តល់ល្បឿន ១០០ MBPS លើ fiber។ Ethernet លើខ្សែអាចពង្រីកបានរហូតដល់ ១០០ ម៉ែត្រក្នុងម៉ូដ half-duplex និងអាចឈានដល់អតិបរមា ២០០០ ម៉ែត្រក្នុងម៉ូដ full-duplex លើ multimode fiber។

# Giga-Ethernet
---
បន្ទាប់ពីត្រូវបានណែនាំនៅឆ្នាំ ១៩៩៥ Fast-Ethernet រក្សាបានស្ថានភាពល្បឿនលឿនរបស់ខ្លួនតែរយៈពេលប៉ុន្មានឆ្នាំប៉ុណ្ណោះ។ Giga-Ethernet ត្រូវបានណែនាំដែលមានល្បឿន ១០០០ mbits/វិនាទី។ IEEE802.3ab ធ្វើស្តង់ដារូបនីយកម្ម Giga-Ethernet លើ UTP ដោយប្រើខ្សែ Cat-5, Cat-5e និង Cat-6។ IEEE802.3ah កំណត់ Giga-Ethernet លើ Fiber។

# Virtual LAN
---
LAN ប្រើប្រាស់ Ethernet ដែលដំណើរការលើ shared media។ Shared media នៅក្នុង Ethernet បង្កើតនូវ Broadcast domain តែមួយ និង Collision domain តែមួយ។ ការដាក់បញ្ចូល switches ទៅក្នុង Ethernet បានដោះស្រាយបញ្ហា single collision domain ហើយឧបករណ៍នីមួយៗដែលភ្ជាប់ទៅកាន់ switch ដំណើរការនៅក្នុង collision domain ដាច់ដោយឡែករបស់វា។ ប៉ុន្តែ Switches មិនអាចបំបែក network ទៅជា Broadcast domains ដាច់ដោយឡែកបានទេ។

Virtual LAN គឺជាដំណោះស្រាយមួយដើម្បីបំបែក single Broadcast domain ទៅជា multiple Broadcast domains។ Host នៅក្នុង VLAN មួយមិនអាចទំនាក់ទំនងជាមួយ host នៅក្នុង VLAN មួយផ្សេងទៀតបានទេ។ តាមលំនាំដើម hosts ទាំងអស់ត្រូវបានដាក់នៅក្នុង VLAN តែមួយ។

![[Pasted image 20250131185836.png]]

នៅក្នុងគំនូសតាងនេះ VLANs ផ្សេងៗគ្នាត្រូវបានបង្ហាញដោយប្រើកូដពណ៌ផ្សេងៗគ្នា។ Hosts នៅក្នុង VLAN មួយ ទោះបីជាភ្ជាប់ទៅនឹង Switch តែមួយក៏ដោយ ក៏មិនអាចមើលឃើញ ឬទំនាក់ទំនងជាមួយ hosts នៅក្នុង VLANs ផ្សេងបានដែរ។ VLAN គឺជាបច្ចេកវិទ្យា Layer-2 ដែលធ្វើការយ៉ាងជិតស្និទ្ធជាមួយ Ethernet។ ដើម្បីបញ្ជូន packets រវាង VLANs ពីរផ្សេងគ្នា តម្រូវឱ្យមានឧបករណ៍ Layer-3 ដូចជា Router។

# **4. COMPUTER NETWORK TOPOLOGIES**

# Network Topology
---
បណ្តាញ Network Topology គឺជាការរៀបចំដែលប្រព័ន្ធកុំព្យូទ័រ ឬឧបករណ៍បណ្តាញត្រូវបានតភ្ជាប់ទៅវិញទៅមក។ Topology អាចកំណត់ទាំងផ្នែករូបវន្ត និងផ្នែកតក្កវិជ្ជានៃបណ្តាញ។ ផ្នែកតក្កវិជ្ជា និងរូបវន្តនៃ Topology អាចដូចគ្នា ឬខុសគ្នានៅក្នុងបណ្តាញតែមួយ។

# Point-to-Point
---
បណ្តាញ Point-to-point មានម៉ាស៊ីនចំនួនពីរប៉ុណ្ណោះ ដូចជាកុំព្យូទ័រ switches routers ឬ servers ដែលតភ្ជាប់គ្នាទៅវិញទៅមកដោយប្រើខ្សែតែមួយ។ ជាទូទៅ ចុងទទួលនៃម៉ាស៊ីនមួយត្រូវបានតភ្ជាប់ទៅនឹងចុងផ្ញើនៃម៉ាស៊ីនមួយទៀត និងផ្ទុយមកវិញ។

![[Pasted image 20250131185851.png]]

ប្រសិនបើម៉ាស៊ីនត្រូវបានតភ្ជាប់តាមបែប point-to-point ក្នុងន័យតក្កវិជ្ជា នោះអាចមានឧបករណ៍អន្តរការីច្រើន។ ប៉ុន្តែម៉ាស៊ីនទាំងនោះមិនដឹងពីបណ្តាញដែលនៅពីក្រោម ហើយមើលឃើញគ្នាទៅវិញទៅមកដូចជាពួកគេត្រូវបានតភ្ជាប់ដោយផ្ទាល់។

# Bus Topology
---
ចំពោះ Bus topology ឧបករណ៍ទាំងអស់ចែករំលែកខ្សែទំនាក់ទំនងតែមួយ។ Bus topology អាចមានបញ្ហានៅពេលម៉ាស៊ីនច្រើនផ្ញើទិន្នន័យក្នុងពេលតែមួយ។ ដូច្នេះ topology នេះប្រើ CSMA/CD technology ឬកំណត់ម៉ាស៊ីនមួយជា Bus Master ដើម្បីដោះស្រាយបញ្ហានេះ។ វាជាទម្រង់បណ្តាញសាមញ្ញមួយដែលការខូចខាតនៃឧបករណ៍មួយមិនប៉ះពាល់ដល់ឧបករណ៍ផ្សេងទៀតទេ។ ប៉ុន្តែការខូចខាតនៃខ្សែទំនាក់ទំនងរួមអាចធ្វើឱ្យឧបករណ៍ផ្សេងទៀតទាំងអស់ឈប់ដំណើរការ។

![[Pasted image 20250131185923.png]]

ចុងទាំងសងខាងនៃ shared channel មានឧបករណ៍បញ្ចប់ខ្សែ (line terminator)។ ទិន្នន័យត្រូវបានផ្ញើតែក្នុងទិសដៅតែមួយ ហើយនៅពេលដែលទិន្នន័យទៅដល់ចុងបញ្ចប់ terminator នឹងលុបទិន្នន័យចេញពីខ្សែ។
# Star Topology
---
គ្រប់ host ទាំងអស់នៅក្នុង Star topology តភ្ជាប់ទៅកាន់ឧបករណ៍កណ្តាលមួយ ដែលគេស្គាល់ថាជា hub device ដោយប្រើការតភ្ជាប់បែប point-to-point។ មានន័យថា មានការតភ្ជាប់ point-to-point រវាង host និង hub។ ឧបករណ៍ hub អាចជាឧបករណ៍ណាមួយដូចខាងក្រោម៖

- Layer-1 device ដូចជា hub ឬ repeater
- Layer-2 device ដូចជា switch ឬ bridge
- Layer-3 device ដូចជា router ឬ gateway

![[Pasted image 20250131185943.png]]

ដូចនៅក្នុង Bus topology ហាប់ដើរតួជាចំណុចបរាជ័យតែមួយ។ ប្រសិនបើវាខូច ការតភ្ជាប់របស់ host ទាំងអស់នឹងបរាជ័យ។ រាល់ការទំនាក់ទំនងរវាង host ទាំងអស់ត្រូវឆ្លងកាត់តែតាមរយៈ hub តែប៉ុណ្ណោះ។ Star topology មិនមានតម្លៃថ្លៃទេក្នុងការភ្ជាប់ host មួយទៀត ត្រូវការតែខ្សែកាបមួយប៉ុណ្ណោះ ហើយការតភ្ជាប់គឺសាមញ្ញ។

# Ring Topology
---
នៅក្នុង ring topology host នីមួយៗភ្ជាប់ទៅកាន់ម៉ាស៊ីនពីរផ្សេងទៀត បង្កើតបានជារចនាសម្ព័ន្ធបណ្តាញរាងរង្វង់។ នៅពេលដែល host មួយព្យាយាមទំនាក់ទំនង ឬផ្ញើសារទៅកាន់ host ដែលមិនជាប់គ្នា ទិន្នន័យនឹងត្រូវឆ្លងកាត់ host ជាច្រើនដែលនៅចន្លោះ។ ដើម្បីភ្ជាប់ host មួយទៀតទៅក្នុងរចនាសម្ព័ន្ធដែលមានស្រាប់ អ្នកគ្រប់គ្រងត្រូវការតែខ្សែកាបមួយបន្ថែមប៉ុណ្ណោះ។

![[Pasted image 20250131185958.png]]

ការបរាជ័យនៃម៉ាស៊ីនណាមួយនាំឱ្យមានការបរាជ័យទាំងមូលនៃ ring។ ដូច្នេះ រាល់ការតភ្ជាប់នៅក្នុង ring គឺជាចំណុចនៃការបរាជ័យ។ មានវិធីសាស្ត្រដែលប្រើប្រាស់ ring បម្រុងមួយទៀត។

# Mesh Topology
---
នៅក្នុងប្រភេទ topology នេះ ម៉ាស៊ីនមួយត្រូវបានតភ្ជាប់ទៅកាន់ម៉ាស៊ីនមួយឬច្រើន។ topology នេះមានម៉ាស៊ីនដែលតភ្ជាប់ point-to-point ជាមួយម៉ាស៊ីនផ្សេងទៀតទាំងអស់ ឬក៏អាចមានម៉ាស៊ីនដែលតភ្ជាប់ point-to-point ជាមួយម៉ាស៊ីនមួយចំនួនតូចប៉ុណ្ណោះ។

![[Pasted image 20250131190020.png]]

ម៉ាស៊ីនម្ចាស់ផ្ទះនៅក្នុង Mesh topology ក៏ដើរតួជាប្រដាប់បញ្ជូនបន្តសម្រាប់ម៉ាស៊ីនម្ចាស់ផ្ទះផ្សេងទៀតដែលមិនមានការតភ្ជាប់ដោយផ្ទាល់ពីចំណុចទៅចំណុច។ បច្ចេកវិទ្យា Mesh មានពីរប្រភេទ៖

* **Full Mesh**: ម៉ាស៊ីនម្ចាស់ផ្ទះទាំងអស់មានការតភ្ជាប់ពីចំណុចទៅចំណុចទៅកាន់ម៉ាស៊ីនម្ចាស់ផ្ទះផ្សេងទៀតទាំងអស់នៅក្នុងបណ្តាញ។ ដូច្នេះសម្រាប់ម៉ាស៊ីនម្ចាស់ផ្ទះថ្មីនីមួយៗ n(n-1)/2 ការតភ្ជាប់ត្រូវបានទាមទារ។ វាផ្តល់នូវរចនាសម្ព័ន្ធបណ្តាញដែលអាចទុកចិត្តបានបំផុតក្នុងចំណោម Network topologies ទាំងអស់។

* **Partially Mesh**: មិនមែនម៉ាស៊ីនម្ចាស់ផ្ទះទាំងអស់មានការតភ្ជាប់ពីចំណុចទៅចំណុចទៅកាន់ម៉ាស៊ីនម្ចាស់ផ្ទះផ្សេងទៀតទេ។ ម៉ាស៊ីនម្ចាស់ផ្ទះតភ្ជាប់ទៅគ្នាទៅវិញទៅមកតាមរបៀបណាមួយ។ Topology នេះមានវត្តមាននៅពេលយើងត្រូវការផ្តល់ភាពអាចទុកចិត្តបានដល់ម៉ាស៊ីនម្ចាស់ផ្ទះមួយចំនួនប៉ុណ្ណោះ។

# Tree Topology
---
ដែលត្រូវបានស្គាល់ផងដែរថាជា Hierarchical Topology នេះគឺជាទម្រង់ Network topology ដែលប្រើប្រាស់ច្រើនបំផុតនាពេលបច្ចុប្បន្ន។ Topology នេះធ្វើការចម្លងតាមដូចជា Extended Star topology និងទទួលបានលក្ខណៈសម្បត្តិពី Bus topology។

Topology នេះបែងចែកបណ្តាញទៅជាកម្រិត/ស្រទាប់ច្រើននៃបណ្តាញ។ ជាចម្បងនៅក្នុង LANs បណ្តាញត្រូវបានបែងចែកជាបីស្រទាប់នៃឧបករណ៍បណ្តាញ។ ស្រទាប់ទាបបំផុតគឺជាស្រទាប់ចូលប្រើប្រាស់ដែលកុំព្យូទ័រត្រូវបានភ្ជាប់។ ស្រទាប់កណ្តាលត្រូវបានគេស្គាល់ថាជាស្រទាប់ចែកចាយ ដែលដំណើរការជាអ្នកសម្របសម្រួលរវាងស្រទាប់ខាងលើនិងស្រទាប់ខាងក្រោម។ ស្រទាប់ខ្ពស់បំផុតត្រូវបានគេស្គាល់ថាជាស្រទាប់ស្នូល ហើយជាចំណុចកណ្តាលនៃបណ្តាញ ពោលគឺឫសនៃមែកធាងដែលគ្រប់ណូតចេញពី។

![[Pasted image 20250131190045.png]]

គ្រប់ host ដែលនៅជិតគ្នាមានការតភ្ជាប់ point-to-point រវាងគ្នា។ ដូចគ្នានឹង Bus topology ដែរ ប្រសិនបើ root ដំណើរការមិនបានល្អ នោះ network ទាំងមូលនឹងរងផលប៉ះពាល់ ទោះបីជាវាមិនមែនជាចំណុចបរាជ័យតែមួយក៏ដោយ។ រាល់ការតភ្ជាប់បម្រើជាចំណុចបរាជ័យ ដែលបំបែក network ទៅជាផ្នែកដែលមិនអាចទាក់ទងគ្នាបាន។

# Daisy Chain
---
topology នេះតភ្ជាប់ host ទាំងអស់ក្នុងទម្រង់ជាខ្សែបន្តគ្នា។ ដូចគ្នានឹង Ring topology ដែរ host ទាំងអស់ត្រូវបានតភ្ជាប់ទៅនឹង host ពីរផ្សេងទៀតប៉ុណ្ណោះ លើកលែងតែ host នៅចុងខ្សែ។ មានន័យថា ប្រសិនបើ host នៅចុងក្នុង daisy chain ត្រូវបានតភ្ជាប់គ្នា នោះវាក្លាយជា Ring topology។

![[Pasted image 20250131190113.png]]

រាល់តំណភ្ជាប់ក្នុង daisy chain topology តំណាងឱ្យចំណុចបរាជ័យតែមួយ។ រាល់ការបរាជ័យនៃតំណភ្ជាប់នីមួយៗបំបែក network ជាពីរផ្នែក។ រាល់ host នៅចន្លោះកណ្តាលដើរតួជា relay សម្រាប់ host ដែលនៅជាប់វា។

# Hybrid Topology
---
network structure ដែលមានការរចនាផ្ទុកនូវ topology លើសពីមួយប្រភេទត្រូវបានគេហៅថា hybrid topology។ Hybrid topology ទទួលបានទាំងគុណសម្បត្តិនិងគុណវិបត្តិពី topology ទាំងអស់ដែលបានបញ្ចូល។

![[Pasted image 20250131190129.png]]

រូបភាពខាងលើតំណាងឱ្យ topology ចម្រុះដែលត្រូវបានជ្រើសរើសដោយចៃដន្យ។ topology រួមបញ្ចូលគ្នាអាចមាន
លក្ខណៈនៃ topology ប្រភេទ Star, Ring, Bus និង Daisy-chain។ WAN ភាគច្រើនត្រូវបានតភ្ជាប់តាមរយៈ 
Dual-Ring topology ហើយបណ្តាញដែលភ្ជាប់ទៅកាន់វាភាគច្រើនជាបណ្តាញដែលមាន topology ប្រភេទ Star។ 
Internet គឺជាឧទាហរណ៍ដ៏ល្អបំផុតនៃ Hybrid topology ដែលមានទំហំធំជាងគេ។

# **5. COMPUTER NETWORK MODEL**

វិស្វកម្មបណ្តាញគឺជាកិច្ចការស្មុគស្មាញមួយ ដែលពាក់ព័ន្ធនឹង software, firmware, វិស្វកម្មកម្រិត chip, hardware និងចរន្តអគ្គិសនី។ ដើម្បីធ្វើឱ្យវិស្វកម្មបណ្តាញមានភាពងាយស្រួល គេបានបែងចែកទស្សនទានបណ្តាញទាំងមូលទៅជាស្រទាប់ច្រើន។ ស្រទាប់នីមួយៗមានតួនាទីជាក់លាក់ និងឯករាជ្យពីស្រទាប់ផ្សេងទៀតទាំងអស់។ ប៉ុន្តែជារួម ស្ទើរតែគ្រប់កិច្ចការបណ្តាញទាំងអស់ពឹងផ្អែកលើស្រទាប់ទាំងនេះ។ ស្រទាប់នានាចែករំលែកទិន្នន័យរវាងគ្នា ហើយពួកវាពឹងផ្អែកគ្នាទៅវិញទៅមកតែក្នុងការទទួលទិន្នន័យចូល និងបញ្ជូនទិន្នន័យចេញប៉ុណ្ណោះ។

# Layered Tasks
---
ក្នុងស្ថាបត្យកម្មជាស្រទាប់នៃ Network Model រាល់ដំណើរការបណ្តាញទាំងមូលត្រូវបានបែងចែកជាកិច្ចការតូចៗ។ កិច្ចការតូចៗនីមួយៗត្រូវបានកំណត់ទៅឱ្យស្រទាប់ជាក់លាក់មួយ ដែលធ្វើការដោយប្តូរផ្តាច់ដើម្បីដំណើរការកិច្ចការនោះតែប៉ុណ្ណោះ។ ស្រទាប់នីមួយៗធ្វើតែការងារជាក់លាក់របស់ខ្លួន។

នៅក្នុងប្រព័ន្ធទំនាក់ទំនងជាស្រទាប់ ស្រទាប់មួយនៃម៉ាស៊ីនដោះស្រាយកិច្ចការដែលត្រូវបានធ្វើដោយ ឬត្រូវធ្វើដោយស្រទាប់ស្របគ្នានៅកម្រិតដូចគ្នានៅលើម៉ាស៊ីនពីចម្ងាយ។ កិច្ចការនេះត្រូវបានផ្តើមឡើងដោយស្រទាប់នៅកម្រិតទាបបំផុត ឬនៅកម្រិតខ្ពស់បំផុត។ ប្រសិនបើកិច្ចការត្រូវបានផ្តើមឡើងដោយស្រទាប់កំពូល វាត្រូវបានបញ្ជូនទៅស្រទាប់ខាងក្រោមវាសម្រាប់ការដំណើរការបន្ថែម។ ស្រទាប់ក្រោមធ្វើដូចគ្នា វាដំណើរការកិច្ចការនិងបញ្ជូនទៅស្រទាប់ក្រោម។ ប្រសិនបើកិច្ចការត្រូវបានផ្តើមឡើងដោយស្រទាប់ក្រោមបំផុត នោះវានឹងដំណើរការតាមផ្លូវបញ្ច្រាស់វិញ។

![[Pasted image 20250131190148.png]]

ស្រទាប់នីមួយៗដាក់បញ្ចូលគ្នានូវរាល់នីតិវិធី protocols និងវិធីសាស្ត្រទាំងអស់ដែលវាត្រូវការដើម្បីអនុវត្តផ្នែកនៃកិច្ចការរបស់វា។ គ្រប់ស្រទាប់ទាំងអស់កំណត់អត្តសញ្ញាណភាគីដៃគូរបស់ពួកគេតាមរយៈ encapsulation header និង tail។

# OSI Model
---
Open System Interconnect គឺជាស្តង់ដារបើកចំហសម្រាប់ប្រព័ន្ធទំនាក់ទំនងទាំងអស់។ គំរូ OSI ត្រូវបានបង្កើតឡើងដោយអង្គការស្តង់ដារអន្តរជាតិ (ISO)។ គំរូនេះមានស្រទាប់ចំនួនប្រាំពីរ:

![[Pasted image 20250131190204.png]]

**Application Layer**: ស្រទាប់នេះទទួលខុសត្រូវក្នុងការផ្តល់ចំណុចប្រទាក់ទៅកាន់អ្នកប្រើប្រាស់កម្មវិធី។ ស្រទាប់នេះរួមបញ្ចូលពិធីការដែលធ្វើអន្តរកម្មដោយផ្ទាល់ជាមួយអ្នកប្រើប្រាស់។

**Presentation Layer**: ស្រទាប់នេះកំណត់ពីរបៀបដែលទិន្នន័យក្នុងទម្រង់ដើមនៃម៉ាស៊ីនចុងក្រោយគួរត្រូវបានបង្ហាញក្នុងទម្រង់ដើមនៃម៉ាស៊ីនម្ចាស់។

**Session Layer**: ស្រទាប់នេះរក្សាសម័យរវាងម៉ាស៊ីនចុងក្រោយ។ ឧទាហរណ៍ នៅពេលដែលការផ្ទៀងផ្ទាត់ឈ្មោះអ្នកប្រើប្រាស់/ពាក្យសម្ងាត់ត្រូវបានធ្វើរួច ម៉ាស៊ីនចុងក្រោយរក្សាសម័យនេះមួយរយៈ ហើយមិនស្នើសុំការផ្ទៀងផ្ទាត់ម្តងទៀតក្នុងរយៈពេលនោះទេ។

**Transport Layer**: ស្រទាប់នេះទទួលខុសត្រូវសម្រាប់ការដឹកជញ្ជូនពីចុងទៅចុងរវាងម៉ាស៊ីន។

**Network Layer**: ស្រទាប់នេះទទួលខុសត្រូវសម្រាប់ការកំណត់អាសយដ្ឋាន និងកំណត់អត្តសញ្ញាណម៉ាស៊ីនក្នុងបណ្តាញតែមួយ។

**Data Link Layer**: ស្រទាប់នេះទទួលខុសត្រូវសម្រាប់ការអាន និងសរសេរទិន្នន័យពី និងទៅកាន់ខ្សែ។ កំហុសនៃតំណត្រូវបានរកឃើញនៅស្រទាប់នេះ។

**Physical Layer**: ស្រទាប់នេះកំណត់ពីផ្នែករឹង ខ្សែ ការតភ្ជាប់ ថាមពលចេញ អត្រាញាណ ជាដើម។

# Internet Model
---
Internet ប្រើប្រាស់ TCP/IP protocol suite ដែលត្រូវបានគេស្គាល់ថាជា Internet suite។ វាកំណត់ Internet Model ដែលមាននូវស្ថាបត្យកម្មស្រទាប់ចំនួនបួន។ OSI Model គឺជាគំរូទូទៅនៃការទំនាក់ទំនង ប៉ុន្តែ Internet Model គឺជាអ្វីដែល Internet ប្រើប្រាស់សម្រាប់ការទំនាក់ទំនងទាំងអស់របស់វា។ Internet គឺឯករាជ្យពីស្ថាបត្យកម្មបណ្តាញមូលដ្ឋានរបស់វា ដូច្នេះវាគឺជាគំរូរបស់វា។ គំរូនេះមានស្រទាប់ដូចខាងក្រោម:

![[Pasted image 20250131190222.png]]

**Application Layer:** ស្រទាប់នេះកំណត់ protocol ដែលអនុញ្ញាតឱ្យអ្នកប្រើប្រាស់ទំនាក់ទំនងជាមួយបណ្តាញ។ ឧទាហរណ៍៖ FTP, HTTP ជាដើម។

**Transport Layer:** ស្រទាប់នេះកំណត់របៀបដែលទិន្នន័យគួរហូរចេញចូលរវាងម៉ាស៊ីនផ្ទុក។ Protocol សំខាន់នៅស្រទាប់នេះគឺ Transmission Control Protocol (TCP)។ ស្រទាប់នេះធានាថាទិន្នន័យដែលបញ្ជូនរវាងម៉ាស៊ីនផ្ទុកគឺមានលំដាប់ត្រឹមត្រូវ និងទទួលខុសត្រូវចំពោះការបញ្ជូនចុងក្រោយ។

**Internet Layer:** Internet Protocol (IP) ដំណើរការនៅស្រទាប់នេះ។ ស្រទាប់នេះសម្របសម្រួលការកំណត់អាសយដ្ឋាននិងការស្គាល់ម៉ាស៊ីន។ ស្រទាប់នេះកំណត់ផ្លូវ។

**Link Layer:** ស្រទាប់នេះផ្តល់នូវយន្តការនៃការផ្ញើនិងទទួលទិន្នន័យជាក់ស្តែង។ មិនដូច OSI Model នោះទេ ស្រទាប់នេះគឺឯករាជ្យពីផ្នែករឹងបណ្តាញមូលដ្ឋាន។

# **6. COMPUTER NETWORK SECURITY**

នាពេលដំបូងនៃការប្រើប្រាស់ internet វាត្រូវបានកំណត់សម្រាប់តែការប្រើប្រាស់ក្នុងផ្នែកយោធា និងសាកលវិទ្យាល័យសម្រាប់ការស្រាវជ្រាវ និងការអភិវឌ្ឍន៍។ ក្រោយមកទៀត នៅពេលដែលបណ្តាញទាំងអស់បានភ្ជាប់គ្នា និងបង្កើតបាន internet វាត្រូវបានប្រើប្រាស់ជាបណ្តាញសាធារណៈ។ បច្ចុប្បន្ន មនុស្សជាច្រើនផ្ញើទិន្នន័យដែលមានលក្ខណៈរសើប ដូចជា ព័ត៌មានលិខិតឥណទាន ឈ្មោះអ្នកប្រើប្រាស់ និងពាក្យសម្ងាត់ ឯកសារផ្ទាល់ខ្លួន ព័ត៌មានទិញទំនិញតាមអនឡាញ ឬឯកសារសម្ងាត់។

ការគំរាមកំហែងផ្នែកសន្តិសុខទាំងអស់គឺមានចេតនា មានន័យថា វាកើតឡើងលុះត្រាតែមានការធ្វើឡើងដោយចេតនា។ ការគំរាមកំហែងផ្នែកសន្តិសុខអាចបែងចែកជាប្រភេទដូចខាងក្រោម៖

## Interruption
Interruption គឺជាការគំរាមកំហែងសន្តិសុខដែលប៉ះពាល់ដល់ការប្រើប្រាស់ធនធាន។ ឧទាហរណ៍ អ្នកប្រើប្រាស់មិនអាចចូលប្រើប្រាស់ web-server ឬ web-service ដែលត្រូវបានគេចូលលួច។

## Privacy-Breach
ក្នុងការគំរាមកំហែងនេះ ភាពឯកជនរបស់អ្នកប្រើប្រាស់ត្រូវបានគេរំលោភបំពាន។ នរណាម្នាក់ដែលមិនមែនជាអ្នកប្រើប្រាស់ដែលមានការអនុញ្ញាត កំពុងចូលប្រើ ឬទទួលយកទិន្នន័យដែលផ្ញើ ឬទទួលដោយអ្នកប្រើប្រាស់ដើម។

## Integrity
ប្រភេទនៃការគំរាមកំហែងនេះរួមបញ្ចូលការផ្លាស់ប្តូរ ឬកែប្រែខ្លឹមសារដើមនៃការទំនាក់ទំនង។ អ្នកវាយប្រហារទទួល និងចាប់យកទិន្នន័យដែលផ្ញើដោយអ្នកផ្ញើ ហើយអ្នកវាយប្រហារក៏កែប្រែ ឬបង្កើតទិន្នន័យក្លែងក្លាយ និងផ្ញើទៅអ្នកទទួល។ អ្នកទទួលទទួលបានទិន្នន័យដោយគិតថាវាត្រូវបានផ្ញើពីអ្នកផ្ញើដើម។

## Authenticity
ការគំរាមកំហែងនេះកើតឡើងនៅពេលដែលអ្នកវាយប្រហារ ឬអ្នករំលោភសន្តិសុខបន្លំខ្លួនជាអ្នកប្រើប្រាស់ពិតប្រាកដ និងចូលប្រើប្រាស់ធនធាន ឬទំនាក់ទំនងជាមួយអ្នកប្រើប្រាស់ពិតប្រាកដផ្សេងទៀត។

គ្មានបច្ចេកវិទ្យាណាមួយអាចផ្តល់សន្តិសុខ 100% បានទេ។ ប៉ុន្តែ វិធានការណ៍នានាអាចត្រូវបានអនុវត្តដើម្បីការពារទិន្នន័យខណៈពេលដែលវាធ្វើដំណើរក្នុងបណ្តាញដែលគ្មានសុវត្ថិភាព ឬ internet។ បច្ចេកទេសដែលគេនិយមប្រើបំផុតគឺ Cryptography។

![[Pasted image 20250131190339.png]]

Cryptography គឺជាបច្ចេកទេសដើម្បីអ៊ិនគ្រីបទិន្នន័យ plain-text ដែលធ្វើឱ្យពិបាកយល់និងបកស្រាយ។ មានអាល់ហ្គោរីត Cryptographic ជាច្រើនដែលមាននាពេលបច្ចុប្បន្នដូចខាងក្រោម៖

- Secret Key
- Public Key 
- Message Digest

# Secret Key Encryption
---
អ្នកផ្ញើនិងអ្នកទទួលមានកូនសោសម្ងាត់មួយ។ កូនសោសម្ងាត់នេះត្រូវបានប្រើដើម្បីអ៊ិនគ្រីបទិន្នន័យនៅខាងអ្នកផ្ញើ។ បន្ទាប់ពីទិន្នន័យត្រូវបានអ៊ិនគ្រីប វាត្រូវបានផ្ញើនៅលើដែនសាធារណៈទៅកាន់អ្នកទទួល។ ដោយសារអ្នកទទួលដឹងនិងមាន Secret Key ទិន្នន័យដែលបានអ៊ិនគ្រីបអាចត្រូវបានដោះអ៊ិនគ្រីបយ៉ាងងាយស្រួល។

ឧទាហរណ៍នៃការអ៊ិនគ្រីប Secret Key គឺ Data Encryption Standard (DES)។ ក្នុងការអ៊ិនគ្រីប Secret Key អ្នកប្រើប្រាស់នីមួយៗត្រូវមានកូនសោសម្ងាត់សម្រាប់ម៉ាស៊ីននីមួយៗនៅលើបណ្តាញដែលធ្វើឱ្យពិបាកគ្រប់គ្រង។

# Public Key Encryption
---
ក្នុងប្រព័ន្ធអ៊ិនគ្រីបនេះ អ្នកប្រើប្រាស់ម្នាក់ៗមាន Secret Key ផ្ទាល់ខ្លួននិងវាមិនស្ថិតនៅក្នុងដែនរួមទេ។ Secret Key មិនត្រូវបានបង្ហាញនៅលើដែនសាធារណៈឡើយ។ ជាមួយនឹង Secret Key អ្នកប្រើប្រាស់ម្នាក់ៗមាន Public Key ផងដែរ។ Public Key តែងតែត្រូវបានធ្វើឱ្យសាធារណៈហើយត្រូវបានប្រើដោយអ្នកផ្ញើដើម្បីអ៊ិនគ្រីបទិន្នន័យ។ នៅពេលអ្នកប្រើប្រាស់ទទួលបានទិន្នន័យដែលបានអ៊ិនគ្រីប គាត់អាចដោះអ៊ិនគ្រីបវាយ៉ាងងាយស្រួលដោយប្រើ Secret Key ផ្ទាល់ខ្លួន។

ឧទាហរណ៍នៃការអ៊ិនគ្រីប Public Key គឺ Rivest-Shamir-Adleman (RSA)។

# Message Digest
---
ក្នុងវិធីសាស្ត្រនេះ ទិន្នន័យពិតមិនត្រូវបានផ្ញើទេ ផ្ទុយទៅវិញតម្លៃ hash ត្រូវបានគណនានិងផ្ញើ។ អ្នកប្រើប្រាស់ម្ខាងទៀតគណនាតម្លៃ hash ផ្ទាល់ខ្លួននិងប្រៀបធៀបជាមួយនឹងតម្លៃដែលទើបទទួលបាន។ ប្រសិនបើតម្លៃ hash ទាំងពីរត្រូវគ្នា នោះវាត្រូវបានទទួលយក បើមិនដូច្នោះទេវាត្រូវបានបដិសេធ។

ឧទាហរណ៍នៃ Message Digest គឺ MD5 hashing។ វាត្រូវបានប្រើច្រើនបំផុតក្នុងការផ្ទៀងផ្ទាត់ភាពត្រឹមត្រូវដែលពាក្យសម្ងាត់អ្នកប្រើប្រាស់ត្រូវបានផ្ទៀងផ្ទាត់ជាមួយនឹងពាក្យសម្ងាត់ដែលបានរក្សាទុកនៅលើម៉ាស៊ីនមេ។

# **7. PHYSICAL LAYER INTRODUCTION**

Physical layer នៅក្នុង OSI model មានតួនាទីក្នុងការធ្វើអន្តរកម្មជាមួយ hardware ជាក់ស្តែង និងយន្តការផ្ញើសញ្ញា។ Physical layer គឺជាស្រទាប់តែមួយគត់នៃ OSI network model ដែលធ្វើការជាក់ស្តែងជាមួយនឹងការតភ្ជាប់រូបវន្តនៃស្ថានីយពីរ។ វាកំណត់អំពី hardware equipment, cabling, wiring, frequencies និង pulses ដែលត្រូវបានប្រើដើម្បីតំណាងឱ្យ binary signals ជាដើម។

Physical layer ផ្តល់សេវាកម្មទៅ Data-link layer។ Data-link layer ប្រគល់ binary data ទៅ physical layer។ Physical layer បំលែងពួកវាទៅជា electrical pulses ដែល binary data ត្រូវបានបញ្ជូនតាមរយៈ wired ឬ wireless media។

# Signals
---
នៅពេលដែល data ត្រូវបានបញ្ជូនតាមរយៈ physical medium វាត្រូវតែបំលែងទៅជា electromagnetic signals ជាមុនសិន។ Data itself អាចជា analog ដូចជាសម្លេងមនុស្ស ឬ digital ដូចជាឯកសារនៅលើថាស។ ទាំង analog និង digital data អាចត្រូវបានតំណាងក្នុងទម្រង់ជា digital ឬ analog signals។

## Digital Signals
Digital signals គឺមានលក្ខណៈដាច់ៗពីគ្នា និងតំណាងឱ្យលំដាប់នៃ voltage pulses។ Digital signals ត្រូវបានប្រើនៅក្នុង circuitry នៃប្រព័ន្ធកុំព្យូទ័រ។

## Analog Signals
Analog signals គឺជារលកជាប់ៗគ្នាក្នុងធម្មជាតិ និងត្រូវបានតំណាងដោយ continuous electromagnetic waves។

# Transmission Impairment
---
នៅពេលដែល signals ធ្វើដំណើរតាមរយៈ medium ពួកវាមានទំនោរទៅរកការខូចខាត។ នេះអាចមានហេតុផលជាច្រើនដូចខាងក្រោម៖

## Attenuation
ដើម្បីឱ្យ receiver អាចបកស្រាយទិន្នន័យបានត្រឹមត្រូវ signal ត្រូវតែមានកម្លាំងគ្រប់គ្រាន់។ នៅពេលដែល signal ឆ្លងកាត់ medium វាមានទំនោរទៅរកការចុះខ្សោយ។ នៅពេលដែលវាឆ្លងកាត់ចម្ងាយ វាបាត់បង់កម្លាំង។

## Dispersion
នៅពេលដែល signal ធ្វើដំណើរតាម media វាមានទំនោរទៅរកការរីករាលដាល និងត្រួតគ្នា។ បរិមាណនៃ dispersion អាស្រ័យលើ frequency ដែលប្រើប្រាស់។

## Delay distortion
Signals ត្រូវបានបញ្ជូនតាម media ជាមួយនឹង speed និង frequency ដែលបានកំណត់ជាមុន។ ប្រសិនបើ signal speed និង frequency មិនត្រូវគ្នា មានលទ្ធភាពដែល signal ទៅដល់គោលដៅក្នុងលំដាប់ខុសគ្នា។ arbitrary fashion នៅក្នុង digital media វាមានសារៈសំខាន់ណាស់ដែល bits មួយចំនួនទៅដល់មុន bits ដែលបានផ្ញើមុន។

## Noise
ការរំខានឬការប្រែប្រួលដោយចៃដន្យនៅក្នុង analog ឬ digital signal ត្រូវបានហៅថា Noise ក្នុង signal ដែលអាចធ្វើឱ្យខូចព័ត៌មានពិតដែលកំពុងដឹកជញ្ជូន។ Noise អាចត្រូវបានចាត់ថ្នាក់ដូចខាងក្រោម៖

## Thermal Noise
កម្តៅញុះញង់ electronic conductors នៃ medium ដែលអាចបង្កើត noise ក្នុង media។ រហូតដល់កម្រិតមួយ thermal noise មិនអាចជៀសវាងបាន។

## Intermodulation
នៅពេលដែល frequencies ច្រើនចែករំលែក medium ការរំខានរបស់ពួកវាអាចបង្កើត noise ក្នុង medium។ Intermodulation noise កើតឡើងប្រសិនបើ frequencies ពីរខុសគ្នាកំពុងចែករំលែក medium ហើយមួយក្នុងចំណោមពួកវាមានកម្លាំងខ្លាំងពេក ឬសមាសភាគខ្លួនឯងមិនដំណើរការត្រឹមត្រូវ បន្ទាប់មក resultant frequency អាចនឹងមិនត្រូវបានបញ្ជូនដូចដែលរំពឹងទុក។

## Crosstalk
ប្រភេទនៃ noise នេះកើតឡើងនៅពេលដែល signal បរទេសចូលទៅក្នុង media។ នេះដោយសារតែ signal នៅក្នុង medium មួយប៉ះពាល់ដល់ signal នៃ medium ទីពីរ។

## Impulse
Noise នេះកើតឡើងដោយសារតែការរំខានមិនទៀងទាត់ដូចជា lightning, electricity, short circuit ឬសមាសភាគខូច។ Digital data ភាគច្រើនរងផលប៉ះពាល់ដោយ noise ប្រភេទនេះ។

# Transmission Media
---
Media ដែលព័ត៌មានត្រូវបានផ្ញើរវាងប្រព័ន្ធកុំព្យូទ័រពីរ ត្រូវបានហៅថា transmission media។ Transmission media មានពីរប្រភេទ។

## Guided Media
គ្រប់ខ្សែ/cables ទំនាក់ទំនងទាំងអស់គឺជា guided media ដូចជា UTP, coaxial cables និង fiber Optics។ នៅក្នុង media នេះ sender និង receiver តភ្ជាប់ដោយផ្ទាល់ ហើយព័ត៌មានត្រូវបានផ្ញើ (guided) តាមរយៈវា។

## Unguided Media
ខ្សែឬអាកាសចំហត្រូវបានគេហៅថា unguided media ព្រោះមិនមានការតភ្ជាប់រវាង sender និង receiver។ ព័ត៌មានត្រូវបានផ្សព្វផ្សាយតាមអាកាស ហើយនរណាក៏អាចទទួលព័ត៌មាននេះបាន។

# Channel Capacity
---
ល្បឿននៃការបញ្ជូនព័ត៌មានត្រូវបានគេហៅថា channel capacity។ យើងរាប់វាជា data rate នៅក្នុង digital world។ វាអាស្រ័យលើកត្តាជាច្រើនដូចជា៖

- **Bandwidth**: ដែនកំណត់ផ្នែករូបវន្តនៃប្រព័ន្ធផ្សព្វផ្សាយមូលដ្ឋាន។
- **Error-rate**: ការទទួលបានព័ត៌មានមិនត្រឹមត្រូវដោយសារសំឡេងរំខាន។
- **Encoding**: ចំនួននៃកម្រិតដែលប្រើសម្រាប់ការផ្ញើសញ្ញា។

# Multiplexing
---
Multiplexing គឺជាបច្ចេកទេសដើម្បីលាយនិងផ្ញើលំហូរទិន្នន័យច្រើនតាមរយៈប្រព័ន្ធផ្សព្វផ្សាយតែមួយ។ បច្ចេកទេសនេះត្រូវការហាដវែរប្រព័ន្ធដែលហៅថា multiplexer (MUX) សម្រាប់ការធ្វើ multiplexing លំហូរនិងផ្ញើវាលើប្រព័ន្ធផ្សព្វផ្សាយ និង de-multiplexer (DMUX) ដែលទទួលយកព័ត៌មានពីប្រព័ន្ធផ្សព្វផ្សាយនិងចែកចាយទៅគោលដៅផ្សេងៗគ្នា។

# Switching
---
Switching គឺជាយន្តការដែលទិន្នន័យ/ព័ត៌មានត្រូវបានផ្ញើពីប្រភពទៅគោលដៅដែលមិនបានតភ្ជាប់ដោយផ្ទាល់។ បណ្តាញមានឧបករណ៍តភ្ជាប់គ្នា ដែលទទួលទិន្នន័យពីប្រភពដែលតភ្ជាប់ដោយផ្ទាល់ រក្សាទុកទិន្នន័យ វិភាគវា ហើយបន្តបញ្ជូនទៅឧបករណ៍តភ្ជាប់បន្ទាប់ដែលនៅជិតគោលដៅបំផុត។

![[Pasted image 20250131190411.png]]

# **8. DIGITAL TRANSMISSION**

ទិន្នន័យ ឬព័ត៌មានអាចត្រូវបានរក្សាទុកតាមពីររបៀប គឺ analog និង digital។ សម្រាប់កុំព្យូទ័រដើម្បីប្រើប្រាស់ទិន្នន័យ វាត្រូវតែស្ថិតនៅក្នុងទម្រង់ digital ដាច់ៗពីគ្នា។ ស្រដៀងគ្នានឹងទិន្នន័យដែរ សញ្ញាក៏អាចស្ថិតនៅក្នុងទម្រង់ជា analog និង digital។ ដើម្បីបញ្ជូនទិន្នន័យជា digital វាត្រូវតែបំលែងទៅជាទម្រង់ digital ជាមុនសិន។

# Digital-to-Digital Conversion
---
ផ្នែកនេះពន្យល់ពីរបៀបបំលែងទិន្នន័យ digital ទៅជាសញ្ញា digital។ វាអាចធ្វើបានតាមពីររបៀប គឺ line coding និង block coding។ សម្រាប់ការទំនាក់ទំនងទាំងអស់ line coding គឺចាំបាច់ ខណៈពេលដែល block coding គឺជាជម្រើស។

# Line Coding
---
ដំណើរការនៃការបំលែងទិន្នន័យ digital ទៅជាសញ្ញា digital ត្រូវបានហៅថា Line Coding។ ទិន្នន័យ digital ត្រូវបានរកឃើញក្នុងទម្រង់ជា binary។ វាត្រូវបានតំណាង (រក្សាទុក) ជាផ្នែកខាងក្នុងជាស៊េរីនៃលេខ 1s និង 0s។

![[Pasted image 20250131190426.png]]

សញ្ញា digital ត្រូវបានសម្គាល់ដោយសញ្ញាដាច់ៗពីគ្នា ដែលតំណាងឱ្យទិន្នន័យ digital។ មានប្រភេទនៃ line coding បីប្រភេទ។

![[Pasted image 20250131190439.png]]

# Unipolar Encoding
---
គ្រោងការអ៊ិនកូដ Unipolar ប្រើកម្រិតវ៉ុលមួយដើម្បីតំណាងទិន្នន័យ។ ក្នុងករណីនេះ ដើម្បីតំណាងលេខ binary 1 វ៉ុលខ្ពស់ត្រូវបានបញ្ជូន ហើយដើម្បីតំណាងលេខ 0 គឺគ្មានវ៉ុល។ វាក៏ត្រូវបានហៅថា Unipolar-Non-return-to-zero ដែរ ព្រោះគ្មានស្ថានភាពសម្រាក មានន័យថាវាតំណាងតែ 1 ឬ 0 ប៉ុណ្ណោះ។

![[Pasted image 20250131190448.png]]

# Polar Encoding
---
គ្រោងការអ៊ិនកូដ Polar ប្រើកម្រិតវ៉ុលច្រើនដើម្បីតំណាងតម្លៃ binary។ ការអ៊ិនកូដ Polar មានបួនប្រភេទ៖

## Polar Non Return to Zero (Polar NRZ)
វាប្រើកម្រិតវ៉ុលពីរខុសគ្នាដើម្បីតំណាងតម្លៃ binary។ ជាទូទៅ វ៉ុលវិជ្ជមានតំណាងឱ្យ 1 ហើយតម្លៃអវិជ្ជមានតំណាងឱ្យ 0។ វាក៏ជា NRZ ដែរ ព្រោះគ្មានស្ថានភាពសម្រាក។

គ្រោង NRZ មានពីរប្រភេទរង៖ NRZ-L និង NRZ-I។


![[Pasted image 20250131190500.png]]

NRZ-L ផ្លាស់ប្តូរកម្រិតវ៉ុលនៅពេលជួបប្រទះ bit ផ្សេងគ្នា ខណៈដែល NRZ-I ផ្លាស់ប្តូរវ៉ុលនៅពេលជួបប្រទះលេខ 1។
## Return to Zero (RZ)
បញ្ហានៃ NRZ គឺថា receiver មិនអាចសន្និដ្ឋានបានថាតើ bit មួយបានបញ្ចប់ហើយ និងពេលណាដែល bit បន្ទាប់ចាប់ផ្តើម ក្នុងករណីដែល clock របស់ sender និង receiver មិនត្រូវបានធ្វើសមកាលកម្ម។

![[Pasted image 20250131190554.png]]

RZ ប្រើកម្រិតវ៉ុលត៍បី៖ វ៉ុលត៍វិជ្ជមានតំណាងឱ្យ 1 វ៉ុលត៍អវិជ្ជមានតំណាងឱ្យ 0 និងវ៉ុលត៍សូន្យសម្រាប់គ្មាន។ សញ្ញាផ្លាស់ប្តូរក្នុងអំឡុងពេល bits មិនផ្លាស់ប្តូរ។

## Manchester
គ្រោងការកូដនេះគឺជាការរួមបញ្ចូលគ្នានៃ RZ និង NRZ-L។ ពេលវេលាត្រូវបានបែងចែកជាពីរ។ វាឆ្លងកាត់នៅពាក់កណ្តាលនៃ bit និងផ្លាស់ប្តូរដំណាក់កាលនៅពេលជួប bit ផ្សេង។

## Differential Manchester
គ្រោងការកូដនេះគឺជាការរួមបញ្ចូលគ្នានៃ RZ និង NRZ-1។ វាក៏ឆ្លងកាត់នៅពាក់កណ្តាលនៃ bit ប៉ុន្តែផ្លាស់ប្តូរដំណាក់កាលតែនៅពេលជួប 1 ប៉ុណ្ណោះ។

# Bipolar Encoding
---
Bipolar encoding ប្រើកម្រិតវ៉ុលត៍បី៖ វិជ្ជមាន អវិជ្ជមាន និងសូន្យ។ វ៉ុលត៍សូន្យតំណាងឱ្យ binary 0 ហើយ bit 1 ត្រូវបានតំណាងដោយការប្តូរវ៉ុលត៍វិជ្ជមាន និងអវិជ្ជមាន។

![[Pasted image 20250131190605.png]]

# Block Coding
---
ដើម្បីធានាភាពត្រឹមត្រូវនៃ data frame ដែលបានទទួល bits បន្ថែមត្រូវបានប្រើ។ ឧទាហរណ៍ ក្នុង even-parity មួយ parity bit ត្រូវបានបន្ថែមដើម្បីធ្វើឱ្យចំនួន 1s នៅក្នុង frame គូ។ តាមវិធីនេះចំនួន bits ដើមត្រូវបានបង្កើន។ វាត្រូវបានហៅថា Block Coding។

Block coding ត្រូវបានតំណាងដោយសញ្ញា slash m/n/B។ មានន័យថា m-bit block ត្រូវបានជំនួសដោយ n-bit block ដែល n > m. Block coding មានបីជំហាន៖

1. Division
2. Substitution
3. Determination

បន្ទាប់ពី block coding ត្រូវបានបញ្ចប់ វាត្រូវបានធ្វើ line coding សម្រាប់ការបញ្ជូន។

# Analog-to-Digital Conversion
---
មីក្រូហ្វូននិង camera បង្កើតសំឡេង analog និងវីដេអូ analog ដែលត្រូវបានចាត់ទុកជាទិន្នន័យ analog។ ដើម្បីបញ្ជូនទិន្នន័យ analog នេះតាមរយៈសញ្ញាឌីជីថល យើងត្រូវការធ្វើការបំលែងពី analog ទៅជាឌីជីថល។

ទិន្នន័យ analog គឺជាលំហូរទិន្នន័យជាប់ៗគ្នាក្នុងទម្រង់ជារលក ខណៈដែលទិន្នន័យឌីជីថលគឺជាទិន្នន័យដាច់ៗពីគ្នា។ ដើម្បីបំលែងរលក analog ទៅជាទិន្នន័យឌីជីថល យើងប្រើ Pulse Code Modulation (PCM)។

PCM គឺជាវិធីសាស្ត្រដែលគេប្រើជាទូទៅបំផុតដើម្បីបំលែងទិន្នន័យ analog ទៅជាទម្រង់ឌីជីថល។ វារួមមានបីជំហាន៖

* Sampling
* Quantization
* Encoding

# Sampling
---

![[Pasted image 20250131190638.png]]

សញ្ញា analog ត្រូវបានយកសំណាកនៅរាល់ចន្លោះពេល T។ កត្តាសំខាន់បំផុតក្នុងការធ្វើ sampling គឺអត្រាដែលសញ្ញា analog ត្រូវបានយកសំណាក។ យោងតាម Nyquist Theorem អត្រា sampling ត្រូវតែយ៉ាងហោចណាស់ពីរដងនៃប្រេកង់ខ្ពស់បំផុតនៃសញ្ញា។

# Quantization
---
![[Pasted image 20250131190647.png]]

Sampling ផ្តល់នូវទម្រង់ដាច់ៗនៃសញ្ញា analog ជាប់។ រាល់គំរូដាច់ៗបង្ហាញពីអាំងព្លីទុតនៃសញ្ញា analog នៅពេលនោះ។ ការធ្វើ quantization ត្រូវបានធ្វើឡើងដោយប្រើកម្រិតដែលបានកំណត់ជាមុន។

ចន្លោះរវាងតម្លៃអាំព្លីទូតអតិបរមា និងតម្លៃអាំព្លីទូតអប្បបរមា។ Quantization គឺជាការប៉ាន់ប្រមាណនៃតម្លៃ analog ភ្លាមៗ។

# Encoding
---

![[Pasted image 20250131190658.png]]

នៅក្នុង encoding តម្លៃដែលបានប៉ាន់ប្រមាណនីមួយៗត្រូវបានបំលែងទៅជាទម្រង់ binary។

# Transmission Modes
---
Transmission mode កំណត់ពីរបៀបដែលទិន្នន័យត្រូវបានបញ្ជូនរវាងកុំព្យូទ័រពីរ។ ទិន្នន័យ binary ក្នុងទម្រង់ជា 1s និង 0s អាចត្រូវបានផ្ញើក្នុងរបៀបពីរផ្សេងគ្នា៖ Parallel និង Serial។

## Parallel Transmission

![[Pasted image 20250131190710.png]]

Binary bits ត្រូវបានរៀបចំជាក្រុមដែលមានប្រវែងថេរ។ ទាំង sender និង receiver ត្រូវបានតភ្ជាប់ក្នុងលក្ខណៈ parallel ជាមួយនឹងចំនួនខ្សែទិន្នន័យស្មើគ្នា។ កុំព្យូទ័រទាំងពីរអាចបែងចែករវាងខ្សែទិន្នន័យលំដាប់ខ្ពស់ និងលំដាប់ទាប។ Sender ផ្ញើ bits ទាំងអស់ក្នុងពេលតែមួយ ព្រោះពួកវាត្រូវបានផ្ញើជាក្រុម។

## Serial Transmission
ក្នុង **Serial Transmission**, bits ត្រូវបានផ្ញើមួយក្បាលបន្ទាប់ពីមួយក្បាលក្នុងលំដាប់ជួរ។ **Serial Transmission** ត្រូវការតែប៉ុណ្ណោះមួយ communication channel។

![[Pasted image 20250201122149.png]]

**Serial Transmission** អាចជាប្រភេទ asynchronous ឬ synchronous។

## Asynchronous Serial Transmission

វាត្រូវបានគេហៅថា **Asynchronous** ព្រោះមិនមានសារៈសំខាន់លើ timing។ Data-bits មាន pattern ជាក់លាក់ ហើយវាជួយឱ្យ receiver ស្គាល់ចាប់ផ្តើម និងបញ្ចប់នៃ data bits។ ឧទាហរណ៍, 0 ត្រូវបានបន្ថែមនៅដើម data byte មួយៗ ហើយ 1 ឬច្រើនជាងនេះត្រូវបានបន្ថែមនៅចុង។

Data-frames (bytes) ពីរដែលជាប់គ្នាអាចមាន gap រវាងគ្នា។

## Synchronous Serial Transmission

Timing ក្នុង **Synchronous Transmission** មានសារៈសំខាន់ព្រោះមិនមាន mechanism ដើម្បីស្គាល់ចាប់ផ្តើម និងបញ្ចប់នៃ data bits។ មិនមាន pattern ឬ prefix/suffix method។ Data bits ត្រូវបានផ្ញើក្នុង burst mode ដោយមិនមាន gap រវាង bytes (8-bits)។ Single burst នៃ data bits អាចមានចំនួន bytes ច្រើន។ ដូច្នេះ, timing មានសារៈសំខាន់ខ្លាំងណាស់។

វាស្ថិតលើ receiver ដើម្បីស្គាល់ និងបំបែក bits ទៅជា bytes។ អត្ថប្រយោជន៍នៃ **Synchronous Transmission** គឺមានល្បឿនលឿន ហើយវាមិនមាន overhead នៃ extra header និង footer bits ដូចជា **Asynchronous Transmission**។

# **9. ANALOG TRANSMISSION**

ដើម្បីផ្ញើទិន្នន័យឌីជីថល តាមរយៈប្រព័ន្ធ analog វាត្រូវតែបំលែងទៅជាសញ្ញា analog។ មានករណីពីរផ្សេងគ្នាអាស្រ័យលើការរៀបចំទិន្នន័យ។

**Bandpass:** តម្រង (filters) ត្រូវបានប្រើដើម្បីច្រោះ និងអនុញ្ញាតឱ្យឆ្លងកាត់នូវប្រេកង់ដែលចង់បាន។ Bandpass គឺជាក្រុមប្រេកង់ដែលអាចឆ្លងកាត់តម្រងបាន។

**Low-pass:** Low-pass គឺជាតម្រងដែលអនុញ្ញាតឱ្យសញ្ញាប្រេកង់ទាបឆ្លងកាត់។

នៅពេលទិន្នន័យឌីជីថលត្រូវបានបំលែងទៅជាសញ្ញា bandpass analog វាត្រូវបានហៅថា digital-to-analog conversion។ នៅពេលសញ្ញា low-pass analog ត្រូវបានបំលែងទៅជាសញ្ញា bandpass analog វាត្រូវបានហៅថា analog-to-analog conversion។

# Digital-to-Analog Conversion
---
នៅពេលទិន្នន័យពីកុំព្យូទ័រមួយត្រូវបានផ្ញើទៅកុំព្យូទ័រមួយទៀតតាមរយៈ analog carrier វាត្រូវតែបំលែងទៅជាសញ្ញា analog ជាមុនសិន។ សញ្ញា analog ត្រូវបានកែប្រែដើម្បីឆ្លុះបញ្ចាំងទិន្នន័យឌីជីថល។

សញ្ញា analog ត្រូវបានកំណត់លក្ខណៈដោយ amplitude, frequency និង phase របស់វា។ មានការបំលែង digital-to-analog បីប្រភេទ៖

## Amplitude Shift Keying
នៅក្នុងបច្ចេកទេសបំលែងនេះ amplitude នៃសញ្ញា analog carrier ត្រូវបានកែប្រែដើម្បីឆ្លុះបញ្ចាំងទិន្នន័យ binary។

![[Pasted image 20250201122939.png]]

នៅពេលទិន្នន័យ binary តំណាងឱ្យលេខ 1, amplitude ត្រូវបានរក្សាទុក។ បើមិនដូច្នោះទេ វាត្រូវបានកំណត់ទៅ 0។ ទាំង frequency និង phase នៅតែដូចគ្នាដូចនៅក្នុងសញ្ញា carrier ដើម។

នៅក្នុងបច្ចេកទេសបំលែងនេះ frequency នៃ analog carrier signal ត្រូវបានកែប្រែដើម្បីឆ្លុះបញ្ចាំងទិន្នន័យ binary។

![[Pasted image 20250201123128.png]]

បច្ចេកទេសនេះប្រើប្រាស់ frequencies ពីរគឺ f1 និង f2។ មួយក្នុងចំណោមពីរនេះ ឧទាហរណ៍ f1 ត្រូវបានជ្រើសរើសដើម្បីតំណាងឱ្យលេខ binary 1 ហើយមួយទៀតត្រូវបានប្រើដើម្បីតំណាងឱ្យលេខ binary 0។ ទាំង amplitude និង phase នៃ carrier wave ត្រូវបានរក្សាទុកដដែល។

## Phase Shift Keying
នៅក្នុងគ្រោងការបំលែងនេះ phase នៃ original carrier signal ត្រូវបានផ្លាស់ប្តូរដើម្បីឆ្លុះបញ្ចាំងទិន្នន័យ binary។

![[Pasted image 20250201123138.png]]

នៅពេលដែល binary symbol ថ្មីត្រូវបានជួបប្រទះ phase នៃសញ្ញាត្រូវបានផ្លាស់ប្តូរ។ Amplitude និង frequency នៃ original carrier signal ត្រូវបានរក្សាទុកដដែល។

QPSK ផ្លាស់ប្តូរ phase ដើម្បីឆ្លុះបញ្ចាំងលេខគោលពីរក្នុងពេលតែមួយ។ នេះត្រូវបានធ្វើឡើងក្នុងដំណាក់កាលពីរផ្សេងគ្នា។ ចរន្តសំខាន់នៃទិន្នន័យ binary ត្រូវបានបែងចែកស្មើគ្នាទៅជាចរន្តរងពីរ។ ចរន្តស៊េរីត្រូវបានបែងចែកស្របគ្នាទៅជាចរន្តរងទាំងពីរ ហើយបន្ទាប់មកចរន្តនីមួយៗត្រូវបានបម្លែងទៅជាសញ្ញាឌីជីថលដោយប្រើបច្ចេកទេស NRZ។ ក្រោយមក សញ្ញាឌីជីថលទាំងពីរត្រូវបានបញ្ចូលគ្នា។

# Analog-to-Analog Conversion
---
សញ្ញា analog ត្រូវបានកែប្រែដើម្បីតំណាងឱ្យទិន្នន័យ analog។ ការបម្លែងនេះក៏ត្រូវបានស្គាល់ថាជា Analog Modulation។ Analog modulation តម្រូវនៅពេលដែល bandpass ត្រូវបានប្រើប្រាស់។ ការបម្លែងពី analog ទៅ analog អាចធ្វើបានតាមវិធីបី៖

![[Pasted image 20250201123245.png]]

# Amplitude Modulation
ក្នុងការ modulation នេះ amplitude នៃសញ្ញា carrier ត្រូវបានកែប្រែដើម្បីឆ្លុះបញ្ចាំងទិន្នន័យ analog។

![[Pasted image 20250201124222.png]]

Amplitude modulation ត្រូវបានអនុវត្តតាមរយៈ multiplier។ amplitude នៃ modulating signal (analog data) ត្រូវបានគុណជាមួយនឹង amplitude នៃ carrier frequency ដែលបន្ទាប់មកឆ្លុះបញ្ចាំង analog data។

frequency និង phase នៃ carrier signal នៅតែមិនផ្លាស់ប្តូរ។

## Frequency Modulation
នៅក្នុងបច្ចេកទេស modulation នេះ frequency នៃ carrier signal ត្រូវបានកែប្រែដើម្បីឆ្លុះបញ្ចាំងការផ្លាស់ប្តូរនៅក្នុងកម្រិតវ៉ុលនៃ modulating signal (analog data)។

![[Pasted image 20250201124242.png]]

អាំព្លីទុត និង phase នៃ carrier signal មិនត្រូវបានផ្លាស់ប្តូរទេ។

# Phase Modulation
នៅក្នុងបច្ចេកទេស modulation នេះ phase នៃ carrier signal ត្រូវបាន modulate ដើម្បីឆ្លុះបញ្ចាំងពីការផ្លាស់ប្តូរវ៉ុលនៃសញ្ញាទិន្នន័យ analog។

![[Pasted image 20250201124348.png]]

ការ Phase modulation គឺមានលក្ខណៈស្រដៀងគ្នាទៅនឹង Frequency Modulation ប៉ុន្តែនៅក្នុង Phase modulation ប្រេកង់នៃ carrier signal មិនត្រូវបានបង្កើនឡើងទេ។ ប្រេកង់នៃ carrier signal ត្រូវបានផ្លាស់ប្តូរ (ធ្វើឱ្យកាន់តែច្រើន និងតិច) ដើម្បីឆ្លុះបញ្ចាំងពីការផ្លាស់ប្តូរវ៉ុលនៃ modulating signal។

# **10. TRANSMISSION MEDIA**

បណ្តាញបញ្ជូនគឺជាមធ្យោបាយរូបវន្តដែលការទំនាក់ទំនងកើតឡើងនៅក្នុងបណ្តាញកុំព្យូទ័រ។

# Magnetic Media
---
វិធីដ៏ងាយស្រួលបំផុតមួយដើម្បីផ្ទេរទិន្នន័យពីកុំព្យូទ័រមួយទៅកុំព្យូទ័រមួយទៀត មុនពេលការកើតឡើងនៃ networking គឺត្រូវរក្សាទុកវានៅលើឧបករណ៍ផ្ទុកណាមួយ និងផ្ទេរវាដោយផ្ទាល់ពីស្ថានីយមួយទៅស្ថានីយមួយទៀត។ ទោះបីជាវាហាក់ដូចជាវិធីសាស្ត្រចាស់នៅក្នុងពិភពលោក internet ល្បឿនលឿននាពេលបច្ចុប្បន្នក៏ដោយ ប៉ុន្តៅនៅពេលដែលទំហំទិន្នន័យមានទំហំធំ magnetic media ចូលមកដើរតួនាទីសំខាន់។

ឧទាហរណ៍ ធនាគារមួយត្រូវគ្រប់គ្រងការផ្ទេរទិន្នន័យធំៗនៃអតិថិជនរបស់ខ្លួន រក្សាទុកច្បាប់ចម្លងនៅកន្លែងឆ្ងាយដោយហេតុផលសុវត្ថិភាព និងការពារវាពីគ្រោះមហន្តរាយដែលមិនប្រាកដ។ ប្រសិនបើធនាគារត្រូវការរក្សាទុកទិន្នន័យបម្រុងទុកដ៏ធំរបស់ខ្លួន ការផ្ទេរតាម internet មិនអាចធ្វើទៅបាន។ WAN links ប្រហែលជាមិនអាចគាំទ្រល្បឿនលឿនបានទេ។ ទោះបីជាពួកគេអាចធ្វើបាន តម្លៃក៏ខ្ពស់ពេកដែរ។

ក្នុងករណីបែបនេះ ការបម្រុងទុកទិន្នន័យត្រូវបានរក្សាទុកនៅលើ magnetic tapes ឬ magnetic discs ហើយត្រូវបានផ្លាស់ទីដោយផ្ទាល់ទៅកាន់ទីតាំងឆ្ងាយៗ។

# Twisted Pair Cable
---
Twisted pair cable ត្រូវបានផលិតឡើងពីខ្សែទង់ដែងពីរដែលមានស្រោមការពារព័ទ្ធជុំវិញ រុំមួលជាមួយគ្នាដើម្បីបង្កើតបានជាប្រព័ន្ធមួយ។ ក្នុងចំណោមខ្សែទាំងពីរនេះ មានតែមួយប៉ុណ្ណោះដែលដឹកនាំសញ្ញាពិតប្រាកដ ហើយមួយទៀតត្រូវបានប្រើសម្រាប់ជាចំណុចយោង។ ការរុំមួលរវាងខ្សែទាំងពីរមានប្រយោជន៍ក្នុងការកាត់បន្ថយសំឡេងរំខាន (electro-magnetic interference) និង crosstalk។

![[Pasted image 20250201124542.png]]

មាន Twisted pair cables ពីរប្រភេទ៖
* Shielded Twisted Pair (STP) Cable
* Unshielded Twisted Pair (UTP) Cable

STP ខ្សែមានគូខ្សែវីដែលត្រូវបានគ្របដោយស្រទាប់លោហៈ។ វាធ្វើឱ្យខ្សែកាន់តែមានភាពធន់នឹងសំឡេងរំខាននិង crosstalk។

UTP មានប្រាំពីរប្រភេទ ដែលនីមួយៗសមស្របសម្រាប់ការប្រើប្រាស់ជាក់លាក់។ នៅក្នុងបណ្តាញកុំព្យូទ័រ Cat-5, Cat-5e និង Cat-6 ត្រូវបានប្រើប្រាស់ច្រើនជាងគេ។ ខ្សែ UTP ត្រូវបានភ្ជាប់ដោយឧបករណ៍ភ្ជាប់ RJ45។

# Coaxial Cable
---
ខ្សែ Coaxial មានខ្សែទង់ដែងពីរ។ ខ្សែស្នូលស្ថិតនៅចំកណ្តាល ហើយត្រូវបានផលិតពីអង្គធាតុចម្លងរឹង។ ស្នូលត្រូវបានព័ទ្ធជុំវិញដោយស្រទាប់អ៊ីសូឡង់។ ខ្សែទីពីរត្រូវបានរុំជុំវិញស្រទាប់អ៊ីសូឡង់ ហើយវាក៏ត្រូវបានគ្របដោយស្រទាប់អ៊ីសូឡង់ផងដែរ។ ទាំងអស់នេះត្រូវបានគ្របដោយគម្របប្លាស្ទិក។

![[Pasted image 20250201124701.png]]

ដោយសារតែរចនាសម្ព័ន្ធរបស់វា ខ្សែ coax អាចដឹកនាំសញ្ញាความញឿនខ្ពស់បានល្អជាងខ្សែវីដែលត្រូវបានរុំ។ រចនាសម្ព័ន្ធដែលត្រូវបានរុំផ្តល់នូវការការពារល្អប្រឆាំងនឹងសំឡេងរំខាននិង cross talk។ ខ្សែ Coaxial ផ្តល់នូវល្បឿនបញ្ជូនទិន្នន័យរហូតដល់ 450 mbps។

មានខ្សែ coax បីប្រភេទគឺ RG-59 (Cable TV), RG-58 (Thin Ethernet) និង RG-11 (Thick Ethernet)។ RG មានន័យថា Radio Government។

ខ្សែត្រូវបានភ្ជាប់ដោយប្រើឧបករណ៍ភ្ជាប់ BNC និង BNC-T។ BNC terminator ត្រូវបានប្រើដើម្បីបញ្ចប់ខ្សែនៅចុងបញ្ចប់។

# Power Lines
---
Power Line Communication (PLC) គឺជាបច្ចេកវិទ្យា Layer-1 (Physical Layer) ដែលប្រើប្រាស់ខ្សែភ្លើងដើម្បីបញ្ជូនសញ្ញាទិន្នន័យ។ នៅក្នុង PLC ទិន្នន័យដែលត្រូវបានធ្វើការ modulate ត្រូវបានផ្ញើតាមខ្សែ។ ឧបករណ៍ទទួលនៅចុងម្ខាងទៀតធ្វើការ de-modulate និងបកស្រាយទិន្នន័យ។

ដោយសារខ្សែភ្លើងត្រូវបានប្រើប្រាស់យ៉ាងទូលំទូលាយ PLC អាចធ្វើឱ្យឧបករណ៍ដែលដំណើរការដោយថាមពលអគ្គិសនីទាំងអស់អាចត្រូវបានគ្រប់គ្រង និងតាមដាន។ PLC ដំណើរការក្នុងទម្រង់ half-duplex។

មាន PLC ពីរប្រភេទ៖
- Narrow band PLC
- Broad band PLC

Narrow band PLC ផ្តល់នូវល្បឿនទិន្នន័យទាបរហូតដល់ 100s of kbps ដោយសារវាដំណើរការនៅក្នុងប្រេកង់ទាប (3-500 kHz)។ វាអាចត្រូវបានពង្រីកលើចម្ងាយច្រើនគីឡូម៉ែត្រ។

Broadband PLC ផ្តល់នូវល្បឿនទិន្នន័យខ្ពស់រហូតដល់ 100s of Mbps និងដំណើរការនៅប្រេកង់ខ្ពស់ (1.8 - 250 MHz)។ វាមិនអាចពង្រីកបានច្រើនដូច Narrowband PLC ទេ។

# Fiber Optics
---
Fiber Optic ដំណើរការលើលក្ខណៈសម្បត្តិនៃពន្លឺ។ នៅពេលកាំពន្លឺប៉ះនៅមុំវិក្រិត វាមានទំនោរទៅចាំងផ្លាតនៅ 90 ដឺក្រេ។ លក្ខណៈសម្បត្តិនេះត្រូវបានប្រើប្រាស់នៅក្នុង fiber optic។ ស្នូលនៃខ្សែ fiber optic ត្រូវបានផលិតពីកញ្ចក់គុណភាពខ្ពស់ ឬប្លាស្ទិក។ នៅពេលពន្លឺត្រូវបានបញ្ចេញពីចុងម្ខាង វាធ្វើដំណើរតាមរយៈវា ហើយនៅចុងម្ខាងទៀតឧបករណ៍ចាប់សញ្ញាពន្លឺរកឃើញពន្លឺ និងបំលែងវាទៅជាទិន្នន័យឌីជីថល។

Fiber Optic ផ្តល់នូវល្បឿនខ្ពស់បំផុត។ វាមានពីរប្រភេទ គឺ single mode fiber និង multimode fiber។ Single mode fiber អាចដឹកនាំកាំពន្លឺតែមួយ ខណៈដែល multimode អាចដឹកនាំពន្លឺច្រើនបាច់។

![[Pasted image 20250201124831.png]]

Fiber Optic ក៏មានសមត្ថភាព unidirectional និង bidirectional ផងដែរ។ ដើម្បីភ្ជាប់និងចូលប្រើប្រាស់ fiber optic គេប្រើឧបករណ៍ភ្ជាប់ពិសេស។ ទាំងនេះអាចជា Subscriber Channel (SC), Straight Tip (ST), ឬ MT-RJ។

# **11. WIRELESS TRANSMISSION**

ការបញ្ជូនដោយ Wireless គឺជាទម្រង់នៃមធ្យោបាយបញ្ជូនដោយគ្មានខ្សែ។ ការទំនាក់ទំនងតាម Wireless ពាក់ព័ន្ធនឹងការមិនមានការតភ្ជាប់ផ្លូវរូបវន្តរវាងឧបករណ៍ពីរឬច្រើន ដែលទំនាក់ទំនងគ្នាដោយឥតខ្សែ។ សញ្ញា Wireless ត្រូវបានផ្សព្វផ្សាយនៅក្នុងខ្យល់ និងត្រូវបានទទួលនិងបកប្រែដោយអង់តែនសមស្រប។

នៅពេលដែលអង់តែនត្រូវបានភ្ជាប់ទៅនឹងសៀគ្វីអេឡិចត្រូនិកនៃកុំព្យូទ័រឬឧបករណ៍ឥតខ្សែ វាបំលែងទិន្នន័យឌីជីថលទៅជាសញ្ញាឥតខ្សែ និងផ្សព្វផ្សាយទៅគ្រប់ទិសទីក្នុងកម្រិតប្រេកង់របស់វា។ អ្នកទទួលនៅចុងម្ខាងទៀតទទួលសញ្ញាទាំងនេះ និងបំលែងវាត្រឡប់ទៅជាទិន្នន័យឌីជីថលវិញ។

ផ្នែកតូចមួយនៃស្ប៉ិចត្រូម electromagnetic អាចត្រូវបានប្រើសម្រាប់ការបញ្ជូនឥតខ្សែ។

![[Pasted image 20250201125016.png]]

# Radio Transmission

ប្រេកង់វិទ្យុគឺងាយស្រួលបង្កើត និងដោយសារតែរលកជំហានធំរបស់វា វាអាចទម្លុះទៅតាមជញ្ជាំងនិងរចនាសម្ព័ន្ធផ្សេងៗបាន។ រលកវិទ្យុអាចមានប្រវែងរលកពី 1mm - 100,000km និងមានប្រេកង់ចាប់ពី 3Hz (Extremely Low Frequency) ដល់ 300 GHz (Extremely High Frequency)។ ប្រេកង់វិទ្យុត្រូវបានបែងចែកជាប្រាំមួយ bands។

រលកវិទ្យុនៅប្រេកង់ទាបអាចធ្វើដំណើរតាមជញ្ជាំង ខណៈពេលដែល RF ខ្ពស់ជាងអាចធ្វើដំណើរជាខ្សែត្រង់និងអាចបាត់បង់ទិសដៅ។ ថាមពលនៃរលកប្រេកង់ទាបធ្លាក់ចុះយ៉ាងខ្លាំងនៅពេលដែលពួកវាគ្របដណ្តប់ចម្ងាយឆ្ងាយ។ រលកវិទ្យុប្រេកង់ខ្ពស់មានថាមពលច្រើនជាង។

ប្រេកង់ទាបដូចជា VLF, LF, MF bands អាចធ្វើដំណើរលើដីរហូតដល់ 1000 គីឡូម៉ែត្រ នៅលើផ្ទៃផែនដី។

![[Pasted image 20250201125025.png]]

រលកវិទ្យុដែលមានប្រេកង់ខ្ពស់ងាយនឹងត្រូវបានស្រូបយកដោយទឹកភ្លៀង និងឧបសគ្គផ្សេងៗ។ ពួកវាប្រើប្រាស់ Ionosphere នៃបរិយាកាសផែនដី។ រលកវិទ្យុប្រេកង់ខ្ពស់ដូចជា HF និង VHF bands ត្រូវបានផ្សព្វផ្សាយឡើងលើ។ នៅពេលពួកវាឈានដល់ Ionosphere ពួកវាត្រូវបានបញ្ចាំងត្រឡប់មកផែនដីវិញ។

![[Pasted image 20250201125154.png]]

# Microwave Transmission
---
រលកអេឡិចត្រូម៉ាញ៉េទិចលើស 100MHz មានទំនោរធ្វើដំណើរជាបន្ទាត់ត្រង់ ហើយសញ្ញាលើពួកវាអាចត្រូវបានផ្ញើដោយការបញ្ជូនរលកទាំងនោះឆ្ពោះទៅកាន់ស្ថានីយជាក់លាក់មួយ។ ដោយសារ Microwaves ធ្វើដំណើរជាបន្ទាត់ត្រង់ ទាំងអ្នកផ្ញើនិងអ្នកទទួលត្រូវតែតម្រឹមឱ្យស្ថិតនៅក្នុងបន្ទាត់ត្រង់ដូចគ្នា។

Microwaves អាចមានជំហានរលកចាប់ពី 1mm ដល់ 1meter និងប្រេកង់ចាប់ពី 300MHz ដល់ 300GHz។

![[Pasted image 20250201125202.png]]

Microwave antennas បង្មួលរលកឲ្យទៅជាបាច់ពន្លឺ។ ដូចបានបង្ហាញក្នុងរូបភាពខាងលើ antennas ច្រើនអាចត្រូវបានតម្រង់ដើម្បីឈានដល់ចម្ងាយកាន់តែឆ្ងាយ។ Microwaves មានប្រេកង់ខ្ពស់ហើយមិនអាចទម្លុះឧបសគ្គជញ្ជាំងបានទេ។

ការបញ្ជូន Microwave អាស្រ័យយ៉ាងខ្លាំងទៅលើលក្ខខណ្ឌអាកាសធាតុ និងប្រេកង់ដែលវាប្រើប្រាស់។

# Infrared Transmission
---
រលក Infrared ស្ថិតនៅចន្លោះស្ពិចត្រូមពន្លឺមើលឃើញ និង microwaves។ វាមានប្រវែងរលក ៧០០nm ទៅ ១mm និងប្រេកង់ចន្លោះពី ៣០០GHz ទៅ ៤៣០THz។

រលក Infrared ត្រូវបានប្រើសម្រាប់ការទំនាក់ទំនងចម្ងាយខ្លីៗដូចជា television និង remote។ Infrared ធ្វើដំណើរជាបន្ទាត់ត្រង់ ដូច្នេះវាមានទិសដៅជាក់លាក់តាមធម្មជាតិ។ ដោយសារប្រេកង់ខ្ពស់ Infrared មិនអាចឆ្លងកាត់ឧបសគ្គបានទេ។

# Light Transmission
---
ស្ពិចត្រូមអេឡិចត្រូម៉ាញ៉េទិចខ្ពស់បំផុតដែលអាចប្រើសម្រាប់ការបញ្ជូនទិន្នន័យគឺពន្លឺ ឬ optical signaling។ នេះសម្រេចបានតាមរយៈ LASER។

ដោយសារប្រេកង់ពន្លឺខ្ពស់ វាមានទំនោរធ្វើដំណើរត្រង់ជាបន្ទាត់។ ដូច្នេះអ្នកផ្ញើនិងអ្នកទទួលត្រូវតែស្ថិតនៅក្នុងខ្សែបន្ទាត់នៃការមើលឃើញ។ ដោយសារការបញ្ជូន laser គឺឯកទិស នៅចុងទាំងពីរនៃការទំនាក់ទំនង laser និង photo-detector ត្រូវតែដំឡើង។ បាច់ពន្លឺ laser មានទទឹងប្រហែល ១mm ដូច្នេះវាជាការងារដ៏ល្អិតល្អន់ក្នុងការតម្រឹម receptors ពីរឆ្ងាយៗដែលចង្អុលទៅប្រភព lasers។

![[Pasted image 20250201125353.png]]

Laser ដំណើរការជា Tx (transmitter) និង photo-detectors ដំណើរការជា Rx (receiver)។

ឡាស៊ែរមិនអាចទម្លុះឧបសគ្គដូចជាជញ្ជាំង ភ្លៀង និងអ័ព្ទដ៏ក្រាស់បានទេ។ លើសពីនេះទៀត laser beam ត្រូវបានបំភាន់ដោយខ្យល់ សីតុណ្ហភាពបរិយាកាស ឬការប្រែប្រួលសីតុណ្ហភាពនៅក្នុងគន្លង។

laser មានសុវត្ថិភាពសម្រាប់ការបញ្ជូនទិន្នន័យ ដោយសារវាពិបាកណាស់ក្នុងការទម្លុះ laser ដែលមានទទឹង 1mm ដោយមិនរំខានដល់ប្រព័ន្ធទំនាក់ទំនង។

# **12. MULTIPLEXING**

Multiplexing គឺជាបច្ចេកទេសដែលលំហូរនៃការបញ្ជូន analog និង digital ផ្សេងៗគ្នាអាចត្រូវបានដំណើរការជាមួយគ្នាលើតំណភ្ជាប់ដែលចែករំលែកគ្នា។ Multiplexing បែងចែកមធ្យោបាយដែលមានសមត្ថភាពខ្ពស់ទៅជាមធ្យោបាយដែលមានសមត្ថភាពទាបតាមក្បួនច្បាប់ ដែលបន្ទាប់មកត្រូវបានចែករំលែកដោយលំហូរផ្សេងៗគ្នា។

ការទំនាក់ទំនងអាចធ្វើឡើងតាមរយៈខ្យល់ (radio frequency) ដោយប្រើប្រព័ន្ធផ្សព្វផ្សាយរូបវន្ត (ខ្សែកាប) និងអុបទិក (fiber)។ គ្រប់មធ្យោបាយទាំងអស់អាចធ្វើ multiplexing បាន។

នៅពេលដែលអ្នកផ្ញើច្រើនព្យាយាមផ្ញើតាមរយៈមធ្យោបាយតែមួយ ឧបករណ៍ដែលហៅថា Multiplexer បែងចែកឆានែលរូបវន្តនិងបែងចែកមួយទៅឱ្យម្នាក់ៗ។ នៅចុងម្ខាងទៀតនៃការទំនាក់ទំនង Demultiplexer ទទួលបានពីមធ្យោបាយតែមួយ កំណត់អត្តសញ្ញាណនីមួយៗ និងផ្ញើទៅអ្នកទទួលផ្សេងៗគ្នា។

# Frequency Division Multiplexing
---
នៅពេលដែល carrier គឺជាความញឹកញាប់ FDM ត្រូវបានប្រើប្រាស់។ FDM គឺជាបច្ចេកវិទ្យា analog។ FDM បែងចែកស្ប៉ិចត្រូម ឬ carrier bandwidth ក្នុងឆានែលតាមក្បួនច្បាប់ និងបែងចែកមួយទៅឱ្យឆានែលនីមួយៗ។ អ្នកប្រើប្រាស់ម្នាក់ៗអាចប្រើប្រាស់ឆានែលញឹកញាប់ដោយឯករាជ្យ និងមានសិទ្ធិប្រើប្រាស់វាទាំងស្រុង។ ឆានែលទាំងអស់ត្រូវបានបែងចែកតាមរបៀបដែលពួកវាមិនត្រួតគ្នា។ ឆានែលត្រូវបានបំបែកដោយ guard bands។ Guard band គឺជាញឹកញាប់ដែលមិនត្រូវបានប្រើដោយឆានែលណាមួយឡើយ។

![[Pasted image 20250201125624.png]]

# Time Division Multiplexing
---
TDM ត្រូវបានអនុវត្តជាចម្បងលើសញ្ញា digital ប៉ុន្តែក៏អាចអនុវត្តលើសញ្ញា analog ផងដែរ។ នៅក្នុង TDM ឆានែលដែលចែករំលែកត្រូវបានបែងចែកក្នុងចំណោមអ្នកប្រើប្រាស់របស់វាតាមរយៈ time slot។ អ្នកប្រើប្រាស់ម្នាក់ៗអាចបញ្ជូនទិន្នន័យក្នុងរយៈពេល time slot ដែលបានផ្តល់ឱ្យតែប៉ុណ្ណោះ។ សញ្ញា digital ត្រូវបានបែងចែកជា frames ស្មើគ្នា ហើយ frame នីមួយៗមានចំនួន time slot ល្អបំផុត។ ទិន្នន័យត្រូវបានបញ្ជូនក្នុង time slot ដែលបានផ្តល់ឱ្យ។

TDM ដំណើរការក្នុងរបៀប synchronized។ ចុងទាំងពីរ គឺ Multiplexer និង De-multiplexer 
ត្រូវបាន synchronized ទាន់ពេលវេលា ហើយទាំងពីរប្តូរទៅ channel បន្ទាប់ក្នុងពេលដំណាលគ្នា។

![[Pasted image 20250201125802.png]]

នៅពេល channel A បញ្ជូន frame នៅចុងម្ខាង De-multiplexer ផ្តល់ media ទៅ channel A 
នៅចុងម្ខាងទៀត។ នៅពេល time slot របស់ channel A អស់ ចុងនេះប្តូរទៅ channel B។ នៅចុងម្ខាងទៀត 
De-multiplexer ដំណើរការក្នុងរបៀប synchronized ដូចគ្នា ហើយផ្តល់ media ទៅ channel B។ 
សញ្ញាពី channel ផ្សេងៗធ្វើដំណើរតាមផ្លូវក្នុងរបៀប interleaved។

# Wavelength Division Multiplexing
---
ពន្លឺមានជំហាររលក (wavelength) ខុសៗគ្នា (ពណ៌)។ ក្នុងរបៀប fiber optic សញ្ញា optical carrier 
ច្រើនត្រូវបាន multiplex ចូលទៅក្នុងខ្សែ optical fiber ដោយប្រើ wavelength ខុសៗគ្នា។ 
នេះជាបច្ចេកទេស analog multiplexing ហើយត្រូវបានធ្វើឡើងតាមគំនិតដូចគ្នានឹង FDM 
ប៉ុន្តែប្រើពន្លឺជាសញ្ញាជំនួសវិញ។

![[Pasted image 20250201125816.png]]

លើសពីនេះទៅទៀត នៅលើ wavelength នីមួយៗ time division multiplexing 
អាចត្រូវបានបញ្ចូលដើម្បីទទួលយកសញ្ញាទិន្នន័យបន្ថែម។

# Code Division Multiplexing
---
សញ្ញាទិន្នន័យច្រើនអាចត្រូវបានបញ្ជូនតាមរយៈ frequency តែមួយដោយប្រើ Code Division Multiplexing។ FDM បែងចែក frequency ទៅជាឆាណែលតូចៗ ប៉ុន្តែ CDM អនុញ្ញាតឱ្យអ្នកប្រើប្រាស់របស់វាអាចបញ្ជូនសញ្ញាទាំងអស់នៅពេលតែមួយដោយប្រើ unique code។ CDM ប្រើ orthogonal codes ដើម្បីពង្រាយសញ្ញា។

ស្ថានីយនីមួយៗត្រូវបានកំណត់ដោយ code ពិសេសមួយដែលហៅថា chip។ សញ្ញាធ្វើដំណើរជាមួយ codes ទាំងនេះដោយឯករាជ្យ នៅក្នុង bandwidth ទាំងមូល។ អ្នកទទួលដឹងជាមុននូវ chip code signal ដែលវាត្រូវទទួល។

# **13. SWITCHING**

ការ switching គឺជាដំណើរការបញ្ជូនបន្ត packets ដែលចូលមកពី port មួយទៅកាន់ port ដែលនាំទៅរកគោលដៅ។ នៅពេលទិន្នន័យចូលមកតាម port វាហៅថា ingress ហើយនៅពេលទិន្នន័យចេញពី port ឬចេញទៅក្រៅ វាហៅថា egress។ ប្រព័ន្ធទំនាក់ទំនងអាចមាន switches និង nodes ជាច្រើន។ ជាទូទៅ switching អាចបែងចែកជាពីរប្រភេទសំខាន់ៗ៖

- **Connectionless:** ទិន្នន័យត្រូវបានបញ្ជូនបន្តដោយផ្អែកលើតារាងបញ្ជូនបន្ត។ មិនតម្រូវឱ្យមានការចាប់ដៃជាមុន ហើយការបញ្ជាក់ទទួលគឺជាជម្រើស។

- **Connection Oriented:** មុនពេលបញ្ជូនបន្តទិន្នន័យទៅកាន់គោលដៅ ចាំបាច់ត្រូវបង្កើតសៀគ្វីជាមុនតាមផ្លូវរវាងចំណុចទាំងពីរ។ ទិន្នន័យត្រូវបានបញ្ជូនតាមសៀគ្វីនោះ។ បន្ទាប់ពីការផ្ទេរបានបញ្ចប់ សៀគ្វីត្រូវបានរក្សាទុកសម្រាប់ការប្រើប្រាស់នាពេលអនាគត ឬអាចបិទភ្លាមៗ។

# Circuit Switching
---
នៅពេលដែល nodes ពីរទំនាក់ទំនងគ្នាតាមផ្លូវទំនាក់ទំនងដែលបានកំណត់ជាក់លាក់ វាត្រូវបានហៅថា circuit switching។ ចាំបាច់ត្រូវមានផ្លូវដែលបានកំណត់ជាមុនដែលទិន្នន័យត្រូវធ្វើដំណើរ ហើយគ្មានទិន្នន័យផ្សេងទៀតត្រូវបានអនុញ្ញាតឡើយ។ នៅក្នុង circuit switching ដើម្បីផ្ទេរទិន្នន័យ សៀគ្វីត្រូវតែបង្កើតឡើងដើម្បីឱ្យការផ្ទេរទិន្នន័យអាចកើតឡើងបាន។

សៀគ្វីអាចជាអចិន្ត្រៃយ៍ ឬបណ្ដោះអាសន្ន។ កម្មវិធីដែលប្រើ circuit switching អាចត្រូវឆ្លងកាត់ដំណាក់កាលទាំងបីនេះ៖

- បង្កើតសៀគ្វី
- ផ្ទេរទិន្នន័យ
- ផ្ដាច់សៀគ្វី

![[Pasted image 20250201130327.png]]

ការប្ដូរផ្លាស់សៀគ្វី (Circuit switching) ត្រូវបានរចនាឡើងសម្រាប់កម្មវិធីសម្លេង។ ទូរស័ព្ទគឺជាឧទាហរណ៍ដ៏ល្អបំផុតនៃ circuit switching។ មុនពេលអ្នកប្រើប្រាស់អាចធ្វើការហៅទូរស័ព្ទបាន គន្លងនិម្មិត (virtual path) រវាងអ្នកហៅនិងអ្នកទទួលត្រូវបានបង្កើតឡើងនៅលើបណ្តាញ។

# Message Switching
---
បច្ចេកទេសនេះស្ថិតនៅចន្លោះកណ្តាលនៃ circuit switching និង packet switching។ នៅក្នុង message switching សារទាំងមូលត្រូវបានចាត់ទុកជាឯកតាតែមួយសម្រាប់ការប្ដូរផ្លាស់/ផ្ទេរទាំងស្រុង។

switch ដែលធ្វើការលើ message switching ដំបូងទទួលបានសារទាំងមូលហើយរក្សាទុកវារហូតដល់មានធនធានគ្រប់គ្រាន់ដើម្បីផ្ទេរវាទៅកាន់ការលោតបន្ទាប់។ ប្រសិនបើការលោតបន្ទាប់មិនមានធនធានគ្រប់គ្រាន់ដើម្បីទទួលយកសារដែលមានទំហំធំ សារនោះត្រូវបានរក្សាទុកហើយ switch រង់ចាំ។

![[Pasted image 20250201130350.png]]

បច្ចេកទេសនេះត្រូវបានចាត់ទុកជាការជំនួសឱ្យ circuit switching។ នៅក្នុង circuit switching គន្លងទាំងមូលត្រូវបានរារាំងសម្រាប់តែអង្គភាពពីរប៉ុណ្ណោះ។ Message switching ត្រូវបានជំនួសដោយ packet switching។ Message switching មានគុណវិបត្តិដូចខាងក្រោម៖

* រាល់ switch នៅក្នុងគន្លងឆ្លងកាត់ត្រូវការទំហំផ្ទុកគ្រប់គ្រាន់ដើម្បីផ្ទុកសារទាំងមូល។

* ដោយសារតែបច្ចេកទេស store-and-forward និងការរង់ចាំរហូតដល់មានធនធាន Message switching មានល្បឿនយឺត។

* Message switching មិនមែនជាដំណោះស្រាយសម្រាប់ streaming media និងកម្មវិធី real-time ទេ។

# Packet Switching
---
គុណវិបត្តិនៃ message switching បានបង្កើតឱ្យមានគំនិតនៃ packet switching។ សារទាំងមូលត្រូវបានបំបែកទៅជាបំណែកតូចៗដែលហៅថា packets។ ព័ត៌មាននៃការបញ្ជូនត្រូវបានបន្ថែមទៅក្នុង header នៃ packet នីមួយៗ ហើយត្រូវបានបញ្ជូនដោយឯករាជ្យ។

វាងាយស្រួលសម្រាប់ឧបករណ៍បណ្តាញអន្តរការីក្នុងការរក្សាទុក packets ទំហំតូច ហើយវាមិនត្រូវការធនធានច្រើនទេទាំងនៅលើគន្លងបញ្ជូន ឬក្នុងអង្គចងចាំខាងក្នុងនៃ switches។

![[Pasted image 20250201130556.png]]

ការប្ដូរកញ្ចប់ទិន្នន័យ (Packet switching) បង្កើនប្រសិទ្ធភាពខ្សែបណ្ដាញ ដោយសារកញ្ចប់ទិន្នន័យពីកម្មវិធីច្រើនអាចធ្វើ multiplex លើ carrier បាន។ អ៊ីនធឺណិតប្រើប្រាស់បច្ចេកទេស packet switching។ ការប្ដូរកញ្ចប់ទិន្នន័យអាចឱ្យអ្នកប្រើប្រាស់ធ្វើការបែងចែកលំហូរទិន្នន័យទៅតាមអាទិភាព។ កញ្ចប់ទិន្នន័យត្រូវបានរក្សាទុក និងបញ្ជូនបន្តទៅតាមអាទិភាពរបស់វា ដើម្បីផ្តល់គុណភាពសេវាកម្ម (quality of service)។

# **14. DATA LINK LAYER INTRODUCTION**

Data Link Layer គឺជាស្រទាប់ទីពីរនៃ OSI Layered Model។ ស្រទាប់នេះគឺជាស្រទាប់មួយដែលស្មុគស្មាញបំផុត និងមានមុខងារនិងការទទួលខុសត្រូវស្មុគស្មាញ។ Data link layer លាក់ព័ត៌មានលម្អិតនៃ hardware ខាងក្រោម ហើយតំណាងខ្លួនវាទៅកាន់ស្រទាប់ខាងលើជាមធ្យោបាយដើម្បីទំនាក់ទំនង។

Data link layer ដំណើរការរវាងម៉ាស៊ីនពីរដែលតភ្ជាប់គ្នាដោយផ្ទាល់។ ការតភ្ជាប់ដោយផ្ទាល់នេះអាចជា point to point ឬ broadcast។ ប្រព័ន្ធនៅលើបណ្តាញ broadcast ត្រូវបានគេនិយាយថាស្ថិតនៅលើ same link។ ការងាររបស់ data link layer កាន់តែស្មុគស្មាញនៅពេលដោះស្រាយជាមួយម៉ាស៊ីនច្រើននៅលើ collision domain តែមួយ។

Data link layer ទទួលខុសត្រូវក្នុងការបំលែងទិន្នន័យទៅជាសញ្ញា bit by bit និងផ្ញើវាតាម hardware ខាងក្រោម។ នៅចុងបញ្ចប់នៃការទទួល Data link layer ប្រមូលទិន្នន័យពី hardware ដែលមានទម្រង់ជាសញ្ញាអេឡិចត្រូនិច រួចប្រមូលផ្តុំវាក្នុងទម្រង់ frame ដែលអាចស្គាល់បាន ហើយបញ្ជូនទៅស្រទាប់ខាងលើ។

Data link layer មានស្រទាប់រងពីរ៖
* Logical Link Control៖ វាដោះស្រាយជាមួយ protocols, flow-control, និង error control។
* Media Access Control៖ វាដោះស្រាយជាមួយការគ្រប់គ្រងជាក់ស្តែងនៃមេឌៀ។

# Functionality of Data-link Layer
---
Data link layer អនុវត្តកិច្ចការជាច្រើនជំនួសឱ្យស្រទាប់ខាងលើ។ ទាំងនេះគឺ៖

## Framing
Data-link layer ទទួលយក packets ពី Network Layer ហើយបញ្ចូលវាទៅក្នុង Frames។ បន្ទាប់មក វាផ្ញើ frame នីមួយៗ bit-by-bit តាម hardware។ នៅចុងបញ្ចប់នៃការទទួល data link layer ប្រមូលសញ្ញាពី hardware ហើយប្រមូលផ្តុំវាទៅជា frames។

## Addressing
Data-link layer ផ្តល់នូវយន្តការ hardware addressing។ Hardware address ត្រូវបានសន្មត់ថាមានតែមួយគត់នៅលើ link។ វាត្រូវបានបញ្ចូលទៅក្នុង hardware នៅពេលផលិត។

## Synchronization
នៅពេល data frames ត្រូវបានផ្ញើតាម link ម៉ាស៊ីនទាំងពីរត្រូវតែ synchronized ដើម្បីឱ្យការផ្ទេរអាចដំណើរការបាន។

## Error Control
ពេលខ្លះសញ្ញាអាចជួបប្រទះបញ្ហាក្នុងការផ្ទេរ ហើយ bits ត្រូវបានប្តូរទិស។ កំហុសទាំងនេះត្រូវបានរកឃើញនិងកែតម្រូវដោយ data bits។ វាក៏ផ្តល់នូវយន្តការរាយការណ៍កំហុសទៅកាន់អ្នកផ្ញើផងដែរ។

## Flow Control
ស្ថានីយនៅលើ link ដូចគ្នាអាចមានល្បឿនឬសមត្ថភាពខុសគ្នា។ Data-link layer ធានាការគ្រប់គ្រងលំហូរដែលអនុញ្ញាតឱ្យម៉ាស៊ីនទាំងពីរផ្លាស់ប្តូរទិន្នន័យក្នុងល្បឿនដូចគ្នា។

## Multi-Access
នៅពេលម៉ាស៊ីននៅលើ shared link ព្យាយាមផ្ទេរទិន្នន័យ វាមានប្រូបាប៊ីលីតេខ្ពស់នៃការប៉ះទង្គិចគ្នា។ Data-link layer ផ្តល់នូវយន្តការដូចជា CSMA/CD ដើម្បីផ្តល់សមត្ថភាពក្នុងការចូលប្រើប្រាស់ shared media រវាងប្រព័ន្ធច្រើន។

# **15. ERROR DETECTION AND CORRECTION**

មានហេតុផលជាច្រើនដូចជា noise, cross-talk ជាដើម ដែលអាចធ្វើឱ្យ data ត្រូវបានខូចក្នុងពេលធ្វើការបញ្ជូន។ upper layers ធ្វើការលើទិដ្ឋភាពទូទៅនៃ network architecture ហើយមិនដឹងពីការដំណើរការ hardware data ជាក់ស្តែងទេ។ ដូច្នេះ upper layers រំពឹងថានឹងមានការបញ្ជូនដោយគ្មានកំហុសរវាងប្រព័ន្ធទាំងនេះ។ applications ភាគច្រើននឹងមិនដំណើរការត្រឹមត្រូវទេប្រសិនបើទទួលបាន data ខុស។ applications ដូចជាសម្លេងនិងវីដេអូប្រហែលជាមិនរងផលប៉ះពាល់ទេ ហើយនៅតែអាចដំណើរការបានល្អជាមួយនឹងកំហុសមួយចំនួន។

Data-link layer ប្រើប្រាស់យន្តការត្រួតពិនិត្យកំហុសមួយចំនួនដើម្បីធានាថា frames (data bit streams) ត្រូវបានបញ្ជូនដោយមានកម្រិតភាពត្រឹមត្រូវជាក់លាក់។ ប៉ុន្តេដើម្បីយល់ពីរបៀបគ្រប់គ្រងកំហុស វាសំខាន់ត្រូវដឹងថាតើមានប្រភេទកំហុសអ្វីខ្លះដែលអាចកើតឡើង។

# Types of Errors
---
អាចមានកំហុសបីប្រភេទ៖

## Single bit error

![[Pasted image 20250201200258.png]]

នៅក្នុង frame មានតែ bit មួយប៉ុណ្ណោះ នៅទីណាក៏ដោយ ដែលខូច។

## Multiple bits error

![[Pasted image 20250201200322.png]]

Frame ត្រូវបានទទួលដោយមាន bits ច្រើនជាងមួយស្ថិតក្នុងស្ថានភាពខូច។

## Burst error

![[Pasted image 20250201200336.png]]

Frame មាន bits ជាប់ៗគ្នាច្រើនជាងមួយដែលខូច។

យន្តការត្រួតពិនិត្យកំហុសអាចមានវិធីពីរ៖
- Error detection
- Error correction

# Error Detection
---
កំហុសនៅក្នុង frames ដែលបានទទួលត្រូវបានរកឃើញតាមរយៈ Parity Check និង Cyclic Redundancy Check (CRC)។ ក្នុងករណីទាំងពីរ bits បន្ថែមមួយចំនួនត្រូវបានផ្ញើជាមួយ data ពិតប្រាកដដើម្បីបញ្ជាក់ថា bits ដែលបានទទួលនៅចុងម្ខាងទៀតដូចគ្នានឹងអ្វីដែលបានផ្ញើ។ ប្រសិនបើការត្រួតពិនិត្យនៅផ្នែកទទួលបរាជ័យ bits ត្រូវបានចាត់ទុកថាខូច។

## Parity Check
bit បន្ថែមមួយត្រូវបានផ្ញើជាមួយនឹង bits ដើមដើម្បីធ្វើឱ្យចំនួននៃ 1s ជាលេខគូក្នុងករណី even parity ឬលេខសេសក្នុងករណី odd parity។

អ្នកផ្ញើនៅពេលបង្កើត frame រាប់ចំនួន 1s នៅក្នុងវា។ ឧទាហរណ៍ ប្រសិនបើប្រើ even parity ហើយចំនួន 1s គឺជាលេខគូ នោះ bit ដែលមានតម្លៃ 0 ត្រូវបានបន្ថែម។ តាមវិធីនេះចំនួន 1s នៅតែជាលេខគូ។ ប្រសិនបើចំនួន 1s គឺជាលេខសេស ដើម្បីធ្វើឱ្យវាទៅជាលេខគូ bit ដែលមានតម្លៃ 1 ត្រូវបានបន្ថែម។

![[Pasted image 20250201200510.png]]

អ្នកទទួលគ្រាន់តែរាប់ចំនួន 1s នៅក្នុង frame។ ប្រសិនបើចំនួន 1s គឺជាលេខគូ ហើយ even parity ត្រូវបានប្រើ frame ត្រូវបានចាត់ទុកថាមិនខូច ហើយត្រូវបានទទួលយក។ ប្រសិនបើចំនួន 1s គឺជាលេខសេស ហើយ odd parity ត្រូវបានប្រើ frame នៅតែមិនខូច។

ប្រសិនបើមាន bit តែមួយត្រឡប់ក្នុង frame អ្នកទទួលអាចរកឃើញវាដោយរាប់ចំនួន 1s។ ប៉ុន្តែនៅពេលដែល bits ច្រើនជាងមួយមានកំហុស វាពិបាកណាស់សម្រាប់អ្នកទទួលក្នុងការរកឃើញកំហុស។

## Cyclic Redundancy Check (CRC)
CRC គឺជាវិធីសាស្ត្រផ្សេងដើម្បីពិនិត្យមើលថាតើ frame ដែលបានទទួលមាន data ត្រឹមត្រូវឬទេ។ បច្ចេកទេសនេះពាក់ព័ន្ធនឹងការចែក binary នៃ data bits ដែលត្រូវផ្ញើ។ ភាគបែងត្រូវបានបង្កើតដោយប្រើ polynomials។ អ្នកផ្ញើធ្វើប្រតិបត្តិការចែកលើ bits ដែលត្រូវផ្ញើ ហើយគណនាសំណល់។ មុនពេលផ្ញើ bits ពិតប្រាកដ អ្នកផ្ញើបន្ថែមសំណល់នៅចុងបញ្ចប់នៃ bits ពិតប្រាកដ។ data bits ពិតប្រាកដបូកនឹងសំណល់ត្រូវបានហៅថា codeword។ អ្នកផ្ញើបញ្ជូន data នេះទៅកាន់អ្នកទទួល។

![[Pasted image 20250201200553.png]]

នៅចុងម្ខាងទៀត receiver អនុវត្តប្រមាណវិធីចែកលើ codewords ដោយប្រើ CRC divisor ដូចគ្នា។ ប្រសិនបើសំណល់មានសុទ្ធតែលេខសូន្យ នោះ data bits ត្រូវបានទទួលយក បើមិនដូច្នោះទេ វាត្រូវបានចាត់ទុកថាមានការខូចខាតទិន្នន័យក្នុងពេលបញ្ជូន។

# Error Correction
---
ក្នុងពិភពឌីជីថល error correction អាចធ្វើបានតាមពីររបៀប៖

## Backward Error Correction

នៅពេលដែល receiver រកឃើញកំហុសនៅក្នុងទិន្នន័យដែលបានទទួល វាស្នើទៅ sender ឱ្យបញ្ជូនទិន្នន័យម្តងទៀត។

## Forward Error Correction

នៅពេលដែល receiver រកឃើញកំហុសមួយចំនួននៅក្នុងទិន្នន័យដែលបានទទួល វាអនុវត្ត error-correction code ដែលអាចជួយស្តារនិងកែតម្រូវកំហុសមួយចំនួន។

របៀបទីមួយ Backward Error Correction គឺសាមញ្ញហើយអាចប្រើប្រាស់បានប្រសិទ្ធភាពតែនៅពេលដែលការបញ្ជូនឡើងវិញមិនថ្លៃពេកប៉ុណ្ណោះ។ ឧទាហរណ៍ fiber optics។ ប៉ុន្តែក្នុងករណីការបញ្ជូនតាមរលកធាតុអាកាស ការបញ្ជូនឡើងវិញអាចមានតម្លៃខ្ពស់។ ក្នុងករណីនេះ Forward Error Correction ត្រូវបានប្រើប្រាស់។

ដើម្បីកែកំហុសក្នុង data frame, receiver ត្រូវដឹងច្បាស់ថាប៊ីតណាមួយក្នុង frame គឺខូច។ ដើម្បីរកប៊ីតដែលមានកំហុស redundant bits ត្រូវបានប្រើជា parity bits សម្រាប់រកកំហុស។ ឧទាហរណ៍ យើងយក ASCII words (7 bits data) បន្ទាប់មកអាចមាន 8 ប្រភេទនៃព័ត៌មាន។ អ្វីដែលយើងត្រូវការគឺ៖ ទីមួយ parity bit មួយដើម្បីប្រាប់ថាមានកំហុសមួយ។

សម្រាប់ m data bits, r redundant bits ត្រូវបានប្រើប្រាស់។ r bits អាចផ្តល់ 2r combinations នៃព័ត៌មាន។ នៅក្នុង m+r bit codeword មានលទ្ធភាពដែល r bits ខ្លួនវាអាចខូច។ ដូច្នេះចំនួននៃ bits ដែលត្រូវប្រើប្រាស់ត្រូវតែផ្តល់ព័ត៌មានអំពីទីតាំង m+r bits បូកនឹងព័ត៌មានគ្មានកំហុស ពោលគឺ n=r+1។

# **16. DATA LINK CONTROL AND PROTOCOLS**

ស្រទាប់ data-link ទទួលខុសត្រូវលើការអនុវត្តនៃលំហូរ point-to-point និងយន្តការគ្រប់គ្រងកំហុស។

# Flow Control
---
នៅពេលដែល data frame (ទិន្នន័យស្រទាប់ទី២) ត្រូវបានផ្ញើពីម៉ាស៊ីនម្ចាស់មួយទៅម៉ាស៊ីនម្ចាស់មួយទៀតតាមរយៈមធ្យោបាយតែមួយ វាតម្រូវឱ្យអ្នកផ្ញើនិងអ្នកទទួលត្រូវធ្វើការក្នុងល្បឿនដូចគ្នា។ ពោលគឺ អ្នកផ្ញើផ្ញើក្នុងល្បឿនមួយដែលអ្នកទទួលអាចដំណើរការនិងទទួលយកទិន្នន័យបាន។ ចុះបើល្បឿន (hardware/software) របស់អ្នកផ្ញើឬអ្នកទទួលខុសគ្នា? បើអ្នកផ្ញើផ្ញើលឿនពេក អ្នកទទួលអាចនឹងលើសចំណុះ (swamped) ហើយទិន្នន័យអាចបាត់បង់។

យន្តការពីរប្រភេទអាចត្រូវបានប្រើប្រាស់ដើម្បីគ្រប់គ្រងលំហូរ:

## Stop and Wait
យន្តការគ្រប់គ្រងលំហូរនេះបង្ខំឱ្យអ្នកផ្ញើបន្ទាប់ពីបញ្ជូន data frame ឱ្យឈប់និងរង់ចាំរហូតដល់ការទទួលស្គាល់នៃ data-frame ដែលបានផ្ញើត្រូវបានទទួល។

![[Pasted image 20250201200916.png]]

## Sliding Window
ក្នុងយន្តការគ្រប់គ្រងលំហូរនេះ ទាំងអ្នកផ្ញើនិងអ្នកទទួលព្រមព្រៀងគ្នាលើចំនួននៃ data-frames ដែលអាចត្រូវបានផ្ញើមុនពេលទទួលបានការទទួលស្គាល់។ ដូចដែលយើងបានរៀន យន្តការគ្រប់គ្រងលំហូរ stop and wait ខ្ជះខ្ជាយធនធាន ពិធីការនេះព្យាយាមប្រើប្រាស់ធនធានមូលដ្ឋានឱ្យបានច្រើនតាមដែលអាចធ្វើទៅបាន។

# Error Control
---
នៅពេលដែល data-frame ត្រូវបានបញ្ជូន វាមានលទ្ធភាពដែល data-frame អាចបាត់បង់ក្នុងការបញ្ជូន ឬទទួលបានដោយខូច។ ក្នុងករណីទាំងពីរ អ្នកទទួលមិនទទួលបាន data-frame ត្រឹមត្រូវ ហើយអ្នកផ្ញើក៏មិនដឹងអំពីការបាត់បង់នេះដែរ។ ក្នុងករណីបែបនេះ ទាំងអ្នកផ្ញើនិងអ្នកទទួលត្រូវបានបំពាក់ដោយពិធីការមួយចំនួនដែលជួយពួកគេឱ្យរកឃើញកំហុសដូចជាការបាត់បង់ data-frame។ ដូច្នេះ អ្នកផ្ញើបញ្ជូន data-frame ម្តងទៀត ឬអ្នកទទួលអាចស្នើសុំឱ្យបញ្ជូន data-frame មុនម្តងទៀត។

តម្រូវការសម្រាប់យន្តការគ្រប់គ្រងកំហុស៖

- **ការរកឃើញកំហុស (Error detection):** អ្នកផ្ញើនិងអ្នកទទួល ទាំងពីរឬណាមួយ ត្រូវតែប្រាកដថាមានកំហុសក្នុងការបញ្ជូន។

- **ការទទួលស្គាល់វិជ្ជមាន (Positive ACK):** នៅពេលអ្នកទទួលទទួលបាន frame ត្រឹមត្រូវ គួរតែទទួលស្គាល់វា។

- **ការទទួលស្គាល់អវិជ្ជមាន (Negative ACK):** នៅពេលអ្នកទទួលទទួលបាន frame ដែលខូច ឬស្ទួន វាផ្ញើ NACK ត្រឡប់ទៅអ្នកផ្ញើវិញ ហើយអ្នកផ្ញើត្រូវតែបញ្ជូន frame ត្រឹមត្រូវម្តងទៀត។

- **ការបញ្ជូនឡើងវិញ (Retransmission):** អ្នកផ្ញើរក្សានាឡិកាមួយ និងកំណត់ពេលវេលាផុតកំណត់។ ប្រសិនបើការទទួលស្គាល់នៃ data-frame ដែលបានបញ្ជូនពីមុនមិនមកដល់មុនពេលផុតកំណត់ អ្នកផ្ញើនឹងបញ្ជូនឡើងវិញនូវ frame ដោយគិតថា frame ឬការទទួលស្គាល់របស់វាបានបាត់បង់ក្នុងការបញ្ជូន។

មានបច្ចេកទេសបីប្រភេទដែល Data-link layer អាចប្រើដើម្បីគ្រប់គ្រងកំហុសដោយ Automatic Repeat Requests (ARQ)៖

## Stop and wait ARQ
![[Pasted image 20250201201230.png]]

ការផ្លាស់ប្តូរខាងក្រោមអាចកើតឡើងនៅក្នុង Stop-and-Wait ARQ៖

- sender រក្សាទុក timeout counter មួយ។

- នៅពេលដែល frame ត្រូវបានផ្ញើ sender ចាប់ផ្តើម timeout counter។

- ប្រសិនបើការទទួលស្គាល់នៃ frame មកដល់ទាន់ពេល sender ផ្ញើ frame បន្ទាប់នៅក្នុង queue។

- ប្រសិនបើការទទួលស្គាល់មិនមកដល់ទាន់ពេល sender សន្មត់ថា frame ឬការទទួលស្គាល់របស់វាត្រូវបានបាត់បង់ក្នុងពេលផ្ទេរ។ Sender ផ្ញើ frame ម្តងទៀត និងចាប់ផ្តើម timeout counter។

- ប្រសិនបើទទួលបានការទទួលស្គាល់អវិជ្ជមាន sender ផ្ញើ frame ម្តងទៀត។

## Go-Back-N ARQ
យន្តការ Stop and wait ARQ មិនប្រើប្រាស់ធនធានឱ្យបានល្អបំផុតទេ។ នៅពេលដែលការទទួលស្គាល់ត្រូវបានទទួល sender ត្រូវរង់ចាំរហូតដល់ timeout។ នៅក្នុងវិធីសាស្ត្រ ARQ នេះ ទាំង sender និង receiver រក្សាទុក window មួយ។

![[Pasted image 20250201201533.png]]

ទំហំ sending-window អនុញ្ញាតឱ្យអ្នកផ្ញើអាចផ្ញើ frames ច្រើនដោយមិនចាំបាច់ទទួលបានការបញ្ជាក់ពី frames មុនៗ។ ទំហំ receiving-window អនុញ្ញាតឱ្យអ្នកទទួលអាចទទួល frames ច្រើននិងបញ្ជាក់ទទួលពួកវា។ អ្នកទទួលរក្សាទុកការតាមដាននូវលេខរៀង sequence number នៃ frames ដែលកំពុងចូលមក។

នៅពេលដែលអ្នកផ្ញើផ្ញើ frames ទាំងអស់នៅក្នុង window វាពិនិត្យមើលថាតើវាបានទទួលការបញ្ជាក់ទទួលរហូតដល់លេខ sequence number ណា។ ប្រសិនបើ frames ទាំងអស់ត្រូវបានបញ្ជាក់ទទួលវិជ្ជមាន អ្នកផ្ញើនឹងផ្ញើ frames បន្ទាប់។ ប្រសិនបើអ្នកផ្ញើរកឃើញថាវាបានទទួល NACK ឬមិនបានទទួល ACK សម្រាប់ frame ជាក់លាក់មួយ វានឹងផ្ញើឡើងវិញនូវ frames ទាំងអស់បន្ទាប់ពីនោះដែលវាមិនទទួលបាន positive ACK។

## Selective Repeat ARQ
នៅក្នុង Go-back-N ARQ គេសន្មតថាអ្នកទទួលមិនមានកន្លែង buffer space សម្រាប់ទំហំ window របស់ខ្លួន និងត្រូវតែដំណើរការ frames តាមលំដាប់។ នេះតម្រូវឱ្យអ្នកផ្ញើផ្ញើឡើងវិញនូវ frames ទាំងអស់ដែលមិនត្រូវបានទទួលស្គាល់។

![[Pasted image 20250201201623.png]]

នៅក្នុង Selective-Repeat ARQ អ្នកទទួល ខណៈពេលដែលតាមដានលេខរៀងនៃ sequence numbers រក្សាទុក frames នៅក្នុងអង្គចងចាំ ហើយផ្ញើ NACK សម្រាប់តែ frame ដែលបាត់ ឬខូច។

អ្នកផ្ញើក្នុងករណីនេះ ផ្ញើតែកញ្ចប់ទិន្នន័យដែលបានទទួល NACK តែប៉ុណ្ណោះ។

# **17. NETWORK LAYER INTRODUCTION**

Layer-3 នៅក្នុង OSI model គឺត្រូវបានគេហៅថា Network layer។ Network layer គ្រប់គ្រងជម្រើសទាក់ទងនឹង host និង network addressing, ការគ្រប់គ្រង sub-networks, និង internetworking។

Network layer មានការទទួលខុសត្រូវក្នុងការ routing packets ពី source ទៅ destination នៅក្នុងឬក្រៅ subnet។ subnet ផ្សេងគ្នាពីរអាចមានគំរូ addressing ផ្សេងគ្នា ឬមិនត្រូវគ្នា។ ដូចគ្នានឹង protocols ដែរ, subnet ផ្សេងគ្នាអាចដំណើរការលើ protocols ផ្សេងគ្នាដែលមិនត្រូវគ្នា។ Network layer មានការទទួលខុសត្រូវក្នុងការ route packets ពី source ទៅ destination, ការផ្គូផ្គងគំរូ addressing និង protocols ផ្សេងៗគ្នា។

# Layer-3 Functionalities
---
ឧបករណ៍ដែលដំណើរការនៅលើ Network Layer ភាគច្រើនផ្តោតលើ routing។ Routing អាចរួមបញ្ចូលកិច្ចការផ្សេងៗដើម្បីសម្រេចគោលដៅតែមួយ។ ទាំងនេះរួមមាន៖

- ការកំណត់អាសយដ្ឋាន devices និង networks
- ការបង្កើតតារាង routing ឬ static routes
- ការរៀបចំជាជួរនូវទិន្នន័យចូលនិងចេញ ហើយបញ្ជូនបន្តទៅតាម quality of service constraints
- Internetworking រវាង subnets ពីរផ្សេងគ្នា
- ការចែកចាយ packets ទៅកាន់គោលដៅដោយប្រើវិធីល្អបំផុត
- ផ្តល់នូវយន្តការទាំង connection oriented និង connection less

# Network Layer Features
---
ជាមួយនឹងមុខងារស្តង់ដាររបស់វា Layer 3 អាចផ្តល់នូវលក្ខណៈពិសេសផ្សេងៗដូចជា៖

- ការគ្រប់គ្រង Quality of service
- Load balancing និង link management
- Security
- ការភ្ជាប់ទំនាក់ទំនងនៃ protocols និង subnets ផ្សេងៗជាមួយ schema ផ្សេងគ្នា
- ការរចនា logical network ផ្សេងៗលើ physical network design
- L3 VPN និង tunnels អាចត្រូវបានប្រើដើម្បីផ្តល់ end to end dedicated connectivity

Internet protocol គឺជា Network Layer protocol ដែលត្រូវបានគេគោរពនិងប្រើប្រាស់យ៉ាងទូលំទូលាយ ដែលជួយឱ្យឧបករណ៍ទាំងអស់អាចទំនាក់ទំនងគ្នាតាមរយៈ Internet។ វាមានពីរប្រភេទ។ IPv4 ដែលបានគ្រប់គ្រងពិភពលោកអស់រយៈពេលជាច្រើនទសវត្សរ៍ ប៊ុន្តឥឡូវកំពុងអស់ address space។ IPv6 ត្រូវបានបង្កើតឡើងដើម្បីជំនួស IPv4 និងដោះស្រាយដែនកំណត់នៃ IPv4 ដូចជា address space។

# **18. NETWORK ADDRESSING**

ការដាក់អាសយដ្ឋាន network នៅ Layer 3 គឺជាកិច្ចការសំខាន់មួយនៃ Network Layer។ អាសយដ្ឋាន Network គឺជាអាសយដ្ឋានតក្កវិជ្ជា មានន័យថាវាជាអាសយដ្ឋានផ្អែកលើ software ដែលអាចផ្លាស់ប្តូរបានតាមរយៈការកំណត់រចនាសម្ព័ន្ធសមស្រប។

អាសយដ្ឋាន network តែងតែចង្អុលទៅកាន់ host / node / server ឬក៏អាចតំណាងឱ្យបណ្តាញទាំងមូល។ អាសយដ្ឋាន network តែងតែត្រូវបានកំណត់រចនាសម្ព័ន្ធនៅលើកាត network interface ហើយជាទូទៅត្រូវបានផ្គូផ្គងដោយប្រព័ន្ធជាមួយនឹងអាសយដ្ឋាន MAC (អាសយដ្ឋាន hardware ឬ layer-2) របស់ម៉ាស៊ីនសម្រាប់ការទំនាក់ទំនង Layer-2។

មានប្រភេទផ្សេងៗគ្នានៃអាសយដ្ឋាន network ដែលមានអត្ថិភាព៖
- IP
- IPX
- AppleTalk

យើងកំពុងពិភាក្សាអំពី IP នៅទីនេះដោយសារវាជាប្រភេទតែមួយគត់ដែលយើងប្រើប្រាស់ជាក់ស្តែងនាពេលបច្ចុប្បន្ន។

![[Pasted image 20250201202218.png]]

IP addressing ផ្តល់នូវយន្តការដើម្បីបែងចែករវាង hosts និង network។ ដោយសារ IP addresses ត្រូវបានកំណត់តាមលំដាប់ថ្នាក់ host តែងតែស្ថិតនៅក្រោម network ជាក់លាក់មួយ។ host ដែលត្រូវការទំនាក់ទំនងនៅក្រៅ subnet របស់វា ត្រូវការដឹងអំពី destination network address ដែលជាកន្លែងដែល packet/data ត្រូវផ្ញើទៅ។

Hosts នៅក្នុង subnet ផ្សេងគ្នាត្រូវការយន្តការដើម្បីស្វែងរកគ្នា។ កិច្ចការនេះអាចធ្វើបានដោយ DNS។ DNS គឺជា server ដែលផ្តល់នូវ Layer-3 address របស់ remote host ដែលត្រូវបានភ្ជាប់ជាមួយ domain name ឬ FQDN របស់វា។ នៅពេល host ទទួលបាន Layer-3 Address (IP Address) របស់ remote host វាបញ្ជូន packet របស់វាទៅកាន់ gateway របស់វា។ Gateway គឺជា router ដែលមានព័ត៌មានទាំងអស់ដែលនាំទៅរក route packets ទៅកាន់ destination host។

Routers ប្រើប្រាស់ routing tables ដែលមានព័ត៌មានដូចខាងក្រោម៖
- Address របស់ destination network
- វិធីសាស្ត្រដើម្បីទៅដល់ network

Routers នៅពេលទទួលបានសំណើបញ្ជូនបន្ត បញ្ជូន packet ទៅកាន់ next hop (adjacent router) ឆ្ពោះទៅកាន់គោលដៅ។

Router បន្ទាប់នៅលើផ្លូវធ្វើដូចគ្នានេះដែរ ហើយទីបំផុត data packet ទៅដល់គោលដៅរបស់វា។

Network address អាចមានមួយក្នុងចំណោមខាងក្រោម៖
- Unicast (សម្រាប់ host មួយ)
- Multicast (សម្រាប់ក្រុម)
- Broadcast (សម្រាប់ទាំងអស់)
- Anycast (សម្រាប់អ្នកនៅជិតបំផុត)

Router មិនបញ្ជូន broadcast traffic ដោយស្វ័យប្រវត្តិទេ។ Multicast traffic ប្រើការព្យាបាលពិសេសដូចជា video stream ឬ audio ជាមួយនឹងអាទិភាពខ្ពស់បំផុត។ Anycast គឺស្រដៀងទៅនឹង unicast លើកលែងតែ packets ត្រូវបានបញ្ជូនទៅកាន់គោលដៅដែលនៅជិតបំផុតនៅពេលមានគោលដៅច្រើនអាចប្រើបាន។

# **19. NETWORK ROUTING**

នៅពេលដែលឧបករណ៍មួយមានផ្លូវច្រើនដើម្បីទៅដល់គោលដៅ វាតែងតែជ្រើសរើសផ្លូវមួយដោយចូលចិត្តវាជាងផ្លូវផ្សេងទៀត។ ដំណើរការជ្រើសរើសនេះត្រូវបានហៅថា Routing។ Routing ត្រូវបានធ្វើឡើងដោយឧបករណ៍បណ្តាញពិសេសដែលហៅថា routers ឬអាចធ្វើបានតាមរយៈដំណើរការកម្មវិធី។ កម្មវិធី software routers មានមុខងារនិងវិសាលភាពមានកំណត់។

router តែងតែត្រូវបានកំណត់រចនាសម្ព័ន្ធជាមួយនឹងផ្លូវលំនាំដើមមួយចំនួន។ default route ប្រាប់ router ពីកន្លែងដែលត្រូវបញ្ជូនកញ្ចប់ទិន្នន័យប្រសិនបើគ្មានផ្លូវត្រូវបានរកឃើញសម្រាប់គោលដៅជាក់លាក់។ ក្នុងករណីដែលមានផ្លូវច្រើនដើម្បីទៅដល់គោលដៅតែមួយ router អាចធ្វើការសម្រេចចិត្តដោយផ្អែកលើព័ត៌មានដូចខាងក្រោម៖

- Hop Count
- Bandwidth
- Metric
- Prefix-length
- Delay

ផ្លូវអាចត្រូវបានកំណត់រចនាសម្ព័ន្ធដោយស្ថិតិ ឬរៀនដោយឌីណាមិក។ ផ្លូវមួយអាចត្រូវបានកំណត់រចនាសម្ព័ន្ធឱ្យចូលចិត្តជាងផ្លូវផ្សេងទៀត។

# Unicast routing
---
ចរាចរណ៍ភាគច្រើននៅលើ Internet និង intranets ដែលស្គាល់ថាជាទិន្នន័យ unicast ឬចរាចរណ៍ unicast ត្រូវបានផ្ញើជាមួយនឹងគោលដៅជាក់លាក់។ ការធ្វើ routing ទិន្នន័យ unicast តាម Internet ត្រូវបានគេហៅថា unicast routing។ វាជាទម្រង់សាមញ្ញបំផុតនៃ routing ព្រោះគោលដៅត្រូវបានស្គាល់រួចហើយ។ ដូច្នេះ router គ្រាន់តែត្រូវមើល routing table និងបញ្ជូនកញ្ចប់ទិន្នន័យទៅ hop បន្ទាប់។

![[Pasted image 20250201202513.png]]

# Broadcast routing
---
តាមលំនាំដើម packet របស់ broadcast មិនត្រូវបានបញ្ជូនបន្ត និងផ្ញើបន្តដោយ router នៅលើបណ្តាញណាមួយឡើយ។ Router បង្កើត broadcast domain។ ប៉ុន្តែវាអាចត្រូវបានកំណត់រចនាសម្ព័ន្ធដើម្បីបញ្ជូនបន្ត broadcast ក្នុងករណីពិសេសមួយចំនួន។ សារ broadcast ត្រូវបានគេផ្ញើទៅឧបករណ៍បណ្តាញទាំងអស់។

ការបញ្ជូនបន្តរបស់ broadcast អាចធ្វើបានតាមពីររបៀប (algorithm)៖

- Router បង្កើត data packet ហើយបន្ទាប់មកផ្ញើវាទៅ host នីមួយៗម្តងមួយៗ។ ក្នុងករណីនេះ router បង្កើតច្បាប់ចម្លងច្រើននៃ data packet តែមួយជាមួយនឹង destination address ផ្សេងៗគ្នា។ packet ទាំងអស់ត្រូវបានផ្ញើជា unicast ប៉ុន្តែដោយសារវាត្រូវបានផ្ញើទៅទាំងអស់គ្នា វាធ្វើសកម្មភាពដូចជា router កំពុង broadcasting។

- វិធីសាស្ត្រនេះប្រើប្រាស់ bandwidth ច្រើន ហើយ router ត្រូវតែមាន destination address របស់ node នីមួយៗ។

- ទីពីរ នៅពេល router ទទួលបាន packet ដែលត្រូវ broadcast វាគ្រាន់តែបញ្ជូន packet ទាំងនោះចេញពីអ៊ីនធឺហ្វេសទាំងអស់។ Router ទាំងអស់ត្រូវបានកំណត់រចនាសម្ព័ន្ធតាមរបៀបដូចគ្នា។

![[Pasted image 20250201202629.png]]

- វិធីសាស្ត្រនេះងាយស្រួលសម្រាប់ CPU របស់ router ប៉ុន្តែអាចបង្កបញ្ហា duplicate packets ដែលទទួលបានពី peer router។

- Reverse path forwarding គឺជាបច្ចេកទេសមួយ ដែល router ដឹងជាមុនអំពី predecessor របស់វាពីកន្លែងដែលវាគួរទទួលបាន broadcast។ បច្ចេកទេសនេះត្រូវបានប្រើដើម្បីរកឃើញ និងបោះបង់ចោល duplicates។

# Multicast Routing
---
Multicast routing គឺជាករណីពិសេសនៃ broadcast routing ដែលមានភាពខុសគ្នាគួរឱ្យកត់សម្គាល់ និងបញ្ហាប្រឈម។ នៅក្នុង broadcast routing កញ្ចប់ទិន្នន័យត្រូវបានផ្ញើទៅកាន់ nodes ទាំងអស់ ទោះបីជាពួកវាមិនត្រូវការក៏ដោយ។ ប៉ុន្តែនៅក្នុង Multicast routing ទិន្នន័យត្រូវបានផ្ញើទៅកាន់តែ nodes ដែលចង់ទទួលកញ្ចប់ទិន្នន័យតែប៉ុណ្ណោះ។

![[Pasted image 20250201202742.png]]

router ត្រូវតែដឹងថាមាន nodes ណាខ្លះដែលចង់ទទួលកញ្ចប់ទិន្នន័យ multicast (ឬ stream) ហើយទើបវាគួរតែបញ្ជូនបន្ត។ Multicast routing ដំណើរការដោយប្រើ spanning tree protocol ដើម្បីជៀសវាងការវិលជុំ។

Multicast routing ក៏ប្រើប្រាស់បច្ចេកទេស reverse path forwarding ផងដែរ ដើម្បីរកឃើញនិងលុបចោល duplicates និង loops។

# Anycast Routing
---
Anycast packet forwarding គឺជាយន្តការដែល hosts ច្រើនអាចមានអាសយដ្ឋាន logical ដូចគ្នា។ នៅពេលដែលកញ្ចប់ទិន្នន័យដែលមានគោលដៅទៅកាន់អាសយដ្ឋាន logical នេះត្រូវបានទទួល វាត្រូវបានផ្ញើទៅកាន់ host ដែលនៅជិតបំផុតនៅក្នុង routing topology។

![[Pasted image 20250201202841.png]]

ការធ្វើ routing Anycast ត្រូវបានធ្វើឡើងដោយមានជំនួយពី DNS server។ នៅពេលណាដែល Anycast packet ត្រូវបានទទួល វាត្រូវបានសាកសួរជាមួយ DNS ដើម្បីកំណត់ថាត្រូវផ្ញើទៅកន្លែងណា។ DNS ផ្តល់នូវ IP address ដែលនៅជិតបំផុតដែលបានកំណត់រចនាសម្ព័ន្ធនៅលើវា។

# Unicast Routing Protocols
---
ពិធីការ routing unicast មានពីរប្រភេទដែលអាចប្រើប្រាស់បានសម្រាប់ route packets unicast៖

## Distance Vector Routing Protocol
Distance Vector គឺជាពិធីការ routing ដែលធ្វើការសម្រេចចិត្តផ្លូវ routing ដោយផ្អែកលើចំនួននៃ hops។ ផ្លូវដែលមានចំនួន hops តិចបំផុតត្រូវបានចាត់ទុកថាជាផ្លូវល្អបំផុត។ router នីមួយៗផ្សព្វផ្សាយផ្លូវល្អបំផុតរបស់ខ្លួនទៅ routers ផ្សេងទៀត។ ឧទាហរណ៍នៃពិធីការនេះគឺ Routing Information Protocol (RIP)។

## Link State Routing Protocol
Link State គឺជាពិធីការដែលស្មុគស្មាញជាង Distance Vector។ វាបែងចែកបណ្តាញទៅជាតំបន់ផ្សេងៗគ្នា។ នេះជួយក្នុងការបង្កើតផែនទីបណ្តាញរួមមួយសម្រាប់ routers ទាំងអស់។ ឧទាហរណ៍នៃពិធីការប្រភេទនេះសម្រាប់ routing unicast រួមមាន Open Shortest Path First (OSPF) និង Intermediate System to Intermediate System (ISIS)។

# Multicast Routing Protocols
---
ពិធីការ routing multicast ប្រើប្រាស់ក្រាហ្វដើម្បីបង្កើតផ្លូវ។ ក្រាហ្វទាំងនេះគឺជា spanning tree ដើម្បីជៀសវាង loops។ ដើមឈើដែលល្អបំផុតត្រូវបានហៅថា shortest path spanning tree។

- **DVMRP**: Distance Vector Multicast Routing Protocol
- **MOSPF**: Multicast Open Shortest Path First
- **CBT**: Core Based Tree
- **PIM**: Protocol Independent Multicast

Protocol Independent Multicast គឺជាពិធីការដែលត្រូវបានប្រើប្រាស់ជាទូទៅនាពេលបច្ចុប្បន្ន។ វាមានពីរប្រភេទ៖

- **PIM Dense Mode**
មុខងារនេះផ្អែកលើការប្រើប្រាស់ flooding។ វាត្រូវបានប្រើក្នុងបរិស្ថានដែលមានដង់ស៊ីតេខ្ពស់ដូចជា LAN។

- **PIM Sparse Mode**
មុខងារនេះប្រើប្រាស់ shared tree។ វាត្រូវបានប្រើក្នុងបរិស្ថានដែលមានដង់ស៊ីតេទាបដូចជា WAN។

# Routing Algorithms
---
អាល់ករីតឹម routing មានដូចខាងក្រោម:

## Flooding
Flooding គឺជាវិធីសាស្ត្រងាយៗបំផុតនៃការបញ្ជូន packet។ នៅពេលទទួលបាន packet មួយ router នឹងបញ្ជូនវាទៅគ្រប់ interfaces លើកលែងតែ interface ដែលវាបានទទួល។ នេះបង្កើត loops ច្រើននៅលើបណ្តាញនិងបណ្តាលឱ្យមានការខ្ជះខ្ជាយធនធានបណ្តាញ។

Time to Live (TTL) អាចត្រូវបានប្រើដើម្បីជៀសវាង looping នៃ packets។ មានវិធីសាស្ត្រផ្សេងទៀតដូចជា Flooding ដែលហៅថា Selective Flooding ដើម្បីកាត់បន្ថយចំនួន packets ដែលបានបញ្ជូន។ នៅក្នុង Selective Flooding router មិនបញ្ជូន packets ទៅគ្រប់ interfaces ទេ តែបញ្ជូនទៅ interfaces ដែលបានជ្រើសរើសប៉ុណ្ណោះ។

## Shortest Path
Shortest Path គឺជាផ្លូវរវាងពីរចំណុចដែលមានចំនួន hops តិចបំផុត។ វាជាបញ្ហាប្រសិទ្ធភាពបណ្តាញ។ hop count គឺជាចំនួនដងដែល packet ត្រូវឆ្លងកាត់ router។ Shortest path គឺជាបច្ចេកទេសដែលប្រើអាល់ករីតឹមផ្សេងៗដើម្បីរកផ្លូវដែលមានចំនួន hops តិចបំផុត។

អាល់ករីតឹម shortest path ទូទៅមាន៖
- Dijkstra's algorithm
- Bellman Ford algorithm
- Floyd Warshall algorithm

# **20. INTERNETWORKING**

នៅក្នុងស្ថានភាពជាក់ស្តែង បណ្តាញដែលស្ថិតក្រោមការគ្រប់គ្រងតែមួយ ជាទូទៅត្រូវបានខ្ចាត់ខ្ចាយទៅតាមទីតាំងភូមិសាស្ត្រផ្សេងៗគ្នា។ អាចមានតម្រូវការក្នុងការតភ្ជាប់បណ្តាញពីរផ្សេងគ្នានៃប្រភេទដូចគ្នា ក៏ដូចជាប្រភេទខុសគ្នា។ ការ routing រវាងបណ្តាញពីរត្រូវបានគេហៅថា internetworking។

បណ្តាញអាចត្រូវបានចាត់ទុកថាខុសគ្នាដោយផ្អែកលើប៉ារ៉ាម៉ែត្រផ្សេងៗដូចជា Protocol, topology, Layer-2 network និង addressing scheme។

នៅក្នុង internetworking, routers មានចំណេះដឹងអំពីអាសយដ្ឋានរបស់គ្នាទៅវិញទៅមក និងអាសយដ្ឋានផ្សេងទៀតដែលនៅហួសពីពួកគេ។ ពួកវាអាចត្រូវបានកំណត់រចនាសម្ព័ន្ធដោយស្តាទិក ឬអាចទៅលើបណ្តាញផ្សេង ឬពួកគេអាចរៀនដោយប្រើ internetworking routing protocol។

![[Pasted image 20250201203557.png]]

ពិធីការ routing ដែលត្រូវបានប្រើនៅក្នុងអង្គការ ឬរដ្ឋបាលត្រូវបានគេហៅថា Interior Gateway Protocols ឬ IGP។ RIP, OSPF គឺជាឧទាហរណ៍នៃ IGP។ ការ Routing រវាងអង្គការ ឬរដ្ឋបាលផ្សេងគ្នាអាចមាន Exterior Gateway Protocol ហើយមានតែ EGP មួយគត់គឺ Border Gateway Protocol។

# Tunneling
---
ប្រសិនបើមានបណ្តាញពីរដែលនៅដាច់ពីគ្នាតាមភូមិសាស្ត្រ ដែលចង់ទំនាក់ទំនងជាមួយគ្នា ពួកគេអាចប្រើប្រាស់ការតភ្ជាប់ដោយផ្ទាល់ ឬត្រូវបញ្ជូនទិន្នន័យតាមរយៈបណ្តាញកណ្តាល។

Tunneling គឺជាយន្តការដែលបណ្តាញពីរឬច្រើនទំនាក់ទំនងជាមួយគ្នា ដោយឆ្លងកាត់បណ្តាញកណ្តាលដែលមានចន្លោះ។ Tunneling តម្រូវឱ្យមានការកំណត់រចនាសម្ព័ន្ធនៅចុងទាំងសងខាង។

![[Pasted image 20250201203633.png]]

នៅពេលដែលទិន្នន័យចូលពីចុងម្ខាងនៃ Tunnel វាត្រូវបានដាក់ស្លាក។ ទិន្នន័យដែលមានស្លាកនេះត្រូវបានបញ្ជូនក្នុងបណ្តាញអន្តរការី ឬ transit network ដើម្បីទៅដល់ចុងម្ខាងទៀតនៃ Tunnel។ នៅពេលទិន្នន័យចេញពី Tunnel ស្លាករបស់វាត្រូវបានដកចេញ ហើយត្រូវបានបញ្ជូនទៅផ្នែកផ្សេងទៀតនៃបណ្តាញ។

ចុងទាំងពីរហាក់ដូចជាភ្ជាប់គ្នាដោយផ្ទាល់ ហើយការដាក់ស្លាកធ្វើឱ្យទិន្នន័យអាចធ្វើដំណើរតាមបណ្តាញ transit network ដោយគ្មានការកែប្រែណាមួយឡើយ។

# Packet Fragmentation
---
ផ្នែកភាគច្រើននៃ Ethernet មាន maximum transmission unit (MTU) កំណត់ត្រឹម 1500 bytes។ កញ្ចប់ទិន្នន័យអាចមានទំហំច្រើន ឬតិចជាងប្រវែងកញ្ចប់នេះ អាស្រ័យលើកម្មវិធី។ ឧបករណ៍នៅក្នុងផ្លូវ transit ក៏មានសមត្ថភាពផ្នែករឹង និងផ្នែកទន់របស់វាដែលប្រាប់ពីបរិមាណទិន្នន័យដែលឧបករណ៍អាចគ្រប់គ្រង និងទំហំកញ្ចប់ដែលវាអាចដំណើរការបាន។

ប្រសិនបើទំហំកញ្ចប់ទិន្នន័យតូចជាង ឬស្មើនឹងទំហំដែលបណ្តាញ transit network អាចគ្រប់គ្រងបាន វាត្រូវបានដំណើរការដោយធម្មតា។ ប្រសិនបើកញ្ចប់មានទំហំធំជាង វាត្រូវបានបំបែកជាបំណែកតូចៗ ហើយបញ្ជូនបន្ត។ នេះហៅថា packet fragmentation។ បំណែកនីមួយៗមានអាសយដ្ឋានប្រភព និងគោលដៅដូចគ្នា ហើយត្រូវបានបញ្ជូនតាមផ្លូវ transit យ៉ាងងាយស្រួល។ នៅពេលទទួលបាន វាត្រូវបានផ្គុំឡើងវិញ។

ប្រសិនបើកញ្ចប់ដែលមាន DF (do not fragment) bit កំណត់ជា 1 មកដល់ router ដែលមិនអាចគ្រប់គ្រងកញ្ចប់បានដោយសារទំហំរបស់វា កញ្ចប់នោះនឹងត្រូវបោះបង់ចោល។

នៅពេលដែលកញ្ចប់ត្រូវបានទទួលដោយ router ហើយមាន MF (more fragments) bit កំណត់ជា 1 នោះ router នឹងដឹងថាវាជាកញ្ចប់ដែលត្រូវបានបំបែក ហើយផ្នែកផ្សេងទៀតនៃកញ្ចប់ដើមកំពុងស្ថិតនៅក្នុងដំណើរការបញ្ជូន។

ប្រសិនបើកញ្ចប់ត្រូវបានបំបែកតូចពេក នោះ overhead នឹងកើនឡើង។ ប្រសិនបើកញ្ចប់ត្រូវបានបំបែកធំពេក router នៅចន្លោះផ្លូវប្រហែលជាមិនអាចដំណើរការវាបាន ហើយវាអាចនឹងត្រូវបោះបង់ចោល។

# **21. NETWORK LAYER PROTOCOLS**

កុំព្យូទ័រនីមួយៗនៅក្នុងបណ្តាញមាន IP address ដែលអាចកំណត់អត្តសញ្ញាណ និងអាសយដ្ឋានដោយផ្ទាល់។ IP address គឺជាអាសយដ្ឋានតក្កវិទ្យានៅ Layer-3 (Network Layer)។ អាសយដ្ឋាននេះអាចផ្លាស់ប្តូរនៅពេលកុំព្យូទ័រចាប់ផ្តើមឡើងវិញ។ កុំព្យូទ័រមួយអាចមាន IP មួយនៅពេលមួយ និង IP ផ្សេងទៀតនៅពេលផ្សេង។

# Address Resolution Protocol (ARP)
---
នៅពេលធ្វើការទំនាក់ទំនង host ត្រូវការ Layer-2 (MAC) address របស់ម៉ាស៊ីនគោលដៅដែលស្ថិតនៅក្នុង domain ឬបណ្តាញតែមួយ។ MAC address ត្រូវបានដុតបញ្ចូលក្នុង Network Interface Card (NIC) របស់ម៉ាស៊ីន ហើយមិនដែលផ្លាស់ប្តូរឡើយ។

ម្យ៉ាងវិញទៀត IP address នៅលើ public domain កម្រនឹងផ្លាស់ប្តូរណាស់។ ប្រសិនបើ NIC ត្រូវបានផ្លាស់ប្តូរដោយសារការខូចខាត MAC address ក៏នឹងផ្លាស់ប្តូរដែរ។ ដូច្នេះ សម្រាប់ Layer-2 communication អាចដំណើរការបាន ការផ្គូផ្គងរវាងពីរនេះគឺចាំបាច់។

![[Pasted image 20250201204133.png]]

ដើម្បីដឹងពីអាសយដ្ឋាន MAC របស់ host ចម្ងាយនៅលើ broadcast domain កុំព្យូទ័រដែលចង់ធ្វើការទំនាក់ទំនងផ្ញើសារ ARP broadcast សួរថា "Who has this IP address?" ដោយសារវាជា broadcast រាល់ host ទាំងអស់នៅលើ network segment ទទួលបាន packet នេះហើយដំណើរការវា។ ARP packet មានផ្ទុកអាសយដ្ឋាន IP របស់ host គោលដៅ និងអាសយដ្ឋាន MAC របស់អ្នកផ្ញើ។ នៅពេល host ទទួលបាន ARP packet សម្រាប់វា វាឆ្លើយតបមកវិញជាមួយអាសយដ្ឋាន MAC របស់ខ្លួន។

នៅពេល host ទទួលបានអាសយដ្ឋាន MAC គោលដៅ វាអាចទំនាក់ទំនងជាមួយ host ចម្ងាយដោយប្រើ Layer-2 link protocol។ ការផ្គូផ្គង IP ទៅ MAC នេះត្រូវបានរក្សាទុកក្នុង ARP cache របស់ host ទាំងពីរ។ លើកក្រោយ បើពួកគេត្រូវការទំនាក់ទំនង ពួកគេអាចយោងដោយផ្ទាល់ទៅ ARP cache របស់ពួកគេ។

Reverse ARP គឺជាយន្តការដែល host ដឹងពីអាសយដ្ឋាន MAC របស់ host ចម្ងាយ ប៉ុន្តែត្រូវការដឹងអាសយដ្ឋាន IP ដើម្បីទំនាក់ទំនង។

# Internet Control Message Protocol (ICMP)
---
ICMP គឺជា protocol សម្រាប់វិនិច្ឆ័យបណ្តាញនិងរាយការណ៍កំហុស។ ICMP ជាផ្នែកនៃ IP protocol suite ហើយប្រើ IP ជា carrier protocol។ បន្ទាប់ពីបង្កើត ICMP packet វាត្រូវបានដាក់ក្នុង IP packet។ ដោយសារ IP ខ្លួនឯងជា protocol មិនអាចទុកចិត្តបាន ដូច្នេះ ICMP ក៏ដូចគ្នា។

រាល់ feedback អំពីបណ្តាញត្រូវបានផ្ញើត្រឡប់ទៅ host ដើម។ បើមានកំហុសកើតឡើងក្នុងបណ្តាញ វាត្រូវបានរាយការណ៍តាមរយៈ ICMP។ ICMP មានសារវិនិច្ឆ័យនិងរាយការណ៍កំហុសជាច្រើន។

ICMP-echo និង ICMP-echo-reply គឺជាសារ ICMP ដែលប្រើច្រើនបំផុតដើម្បីពិនិត្យមើលការភ្ជាប់រវាង host ចុងទាំងពីរ។ នៅពេល host ទទួលបានសំណើ ICMP-echo វាត្រូវតែផ្ញើ ICMP-echo-reply ត្រឡប់មកវិញ។ បើមានបញ្ហាក្នុងបណ្តាញ ICMP នឹងរាយការណ៍ពីបញ្ហានោះ។

# Internet Protocol Version 4 (IPv4)
---
IPv4 គឺជាប្រព័ន្ធអាសយដ្ឋាន 32-bit ដែលប្រើជាយន្តការកំណត់អាសយដ្ឋាន TCP/IP host។ IP addressing អនុញ្ញាតឱ្យ host នីមួយៗនៅលើបណ្តាញ TCP/IP អាចកំណត់អត្តសញ្ញាណបានដោយឯកតោភាគី។

IPv4 ផ្តល់នូវប្រព័ន្ធអាសយដ្ឋានតាមឋានានុក្រមដែលអនុញ្ញាតឱ្យបែងចែកបណ្តាញជា sub-networks ដែលមានចំនួន host ច្បាស់លាស់។ អាសយដ្ឋាន IP ត្រូវបានបែងចែកជាច្រើនប្រភេទ៖

- **Class A:** ប្រើ octet ដំបូងសម្រាប់អាសយដ្ឋានបណ្តាញ និង octet បីចុងក្រោយសម្រាប់អាសយដ្ឋាន host។
- **Class B:** ប្រើ octet ពីរដំបូងសម្រាប់អាសយដ្ឋានបណ្តាញ និងពីរចុងក្រោយសម្រាប់អាសយដ្ឋាន host។
- **Class C:** ប្រើ octet បីដំបូងសម្រាប់អាសយដ្ឋានបណ្តាញ និងមួយចុងក្រោយសម្រាប់អាសយដ្ឋាន host។
- **Class D:** ផ្តល់នូវប្រព័ន្ធអាសយដ្ឋាន IP រាបស្មើ ផ្ទុយពីរចនាសម្ព័ន្ធឋានានុក្រមខាងលើ។
- **Class E:** ប្រើសម្រាប់ការពិសោធន៍។

IPv4 ក៏មានលំហអាសយដ្ឋានច្បាស់លាស់សម្រាប់ប្រើជាអាសយដ្ឋានឯកជន (មិនអាច route លើ internet) និងអាសយដ្ឋានសាធារណៈ (ផ្តល់ដោយ ISPs និងអាច route លើ internet)។

ទោះបីជា IP មិនអាចទុកចិត្តបានក៏ដោយ វាផ្តល់នូវយន្តការ 'Best-Effort-Delivery'។

# Internet Protocol Version 6 (IPv6)
---
ការអស់អាសយដ្ឋាន IPv4 បានបង្កើតឱ្យមាន Internet Protocol version 6។ IPv6 ផ្តល់អាសយដ្ឋាន 128-bit ដល់ nodes របស់វា ដែលផ្តល់លំហអាសយដ្ឋានច្រើនសម្រាប់ប្រើនៅលើភពផែនដីទាំងមូលនិងលើសពីនេះ។

IPv6 បានណែនាំការដាក់អាសយដ្ឋាន Anycast ប៉ុន្តែបានដកចេញនូវគំនិតនៃ broadcasting។ IPv6 អនុញ្ញាតឱ្យឧបករណ៍កំណត់អាសយដ្ឋាន IPv6 ដោយខ្លួនឯងនិងទំនាក់ទំនងក្នុង subnet នោះ។ ការកំណត់រចនាសម្ព័ន្ធដោយស្វ័យប្រវត្តិនេះដកចេញនូវការពឹងផ្អែកលើ Dynamic Host Configuration Protocol (DHCP) server។ តាមរបៀបនេះ ទោះបីជា DHCP server នៅលើ subnet នោះមិនដំណើរការក៏ដោយ hosts អាចទំនាក់ទំនងជាមួយគ្នាបាន។

IPv6 ផ្តល់នូវមុខងារថ្មីនៃ IPv6 mobility។ ម៉ាស៊ីនដែលមាន IPv6 អាចដើរចុះឡើងដោយមិនចាំបាច់ផ្លាស់ប្តូរអាសយដ្ឋាន IP របស់ពួកគេ។

IPv6 នៅតែស្ថិតក្នុងដំណាក់កាលអន្តរកាល និងរំពឹងថានឹងជំនួស IPv4 ទាំងស្រុងនៅពេលខាងមុខ។ បច្ចុប្បន្ន មានបណ្តាញមួយចំនួនតូចប៉ុណ្ណោះដែលកំពុងដំណើរការលើ IPv6។ មានយន្តការអន្តរកាលមួយចំនួនសម្រាប់បណ្តាញដែលប្រើ IPv6 ដើម្បីនិយាយនិងដើរចុះឡើងជាមួយបណ្តាញផ្សេងៗដែលប្រើ IPv4។ ទាំងនោះគឺ៖

- Dual stack implementation
- Tunneling
- NAT-PT

# **22. TRANSPORT LAYER INTRODUCTION**

នៅក្នុង OSI Model, Transport Layer (Layer-4) ត្រូវបានគេទទួលស្គាល់ថាជាស្រទាប់ដែលមានម៉ូឌុល និងដំណើរការទាំងអស់ទាក់ទងនឹងការដឹកជញ្ជូនទិន្នន័យ។ ដូចស្រទាប់ផ្សេងទៀតដែរ ស្រទាប់នេះទំនាក់ទំនងជាមួយស្រទាប់ Transport របស់វាផ្ទាល់នៅលើម៉ាស៊ីនផ្សេងទៀត។

ស្រទាប់នេះផ្តល់នូវការទំនាក់ទំនង peer-to-peer និង end-to-end រវាងដំណើរការនៅលើម៉ាស៊ីនពីចម្ងាយ។ Transport layer ទទួលទិន្នន័យពីស្រទាប់ខាងលើ (ឧ. Application layer) ហើយបែងចែកវាទៅជាផ្នែកតូចៗ ហៅថា segments មុនពេលបញ្ជូនទៅស្រទាប់ខាងក្រោម។

# Functions
---
- ស្រទាប់នេះគឺជាស្រទាប់ដំបូងដែលបំបែកព័ត៌មានដែលផ្តល់ដោយ Application layer ទៅជាផ្នែកតូចៗដែលហៅថា segments។ វាបន្ថែមលេខរៀងទៅក្នុងផ្នែកនីមួយៗ និងធ្វើការតាមដានរបស់វា។

- ស្រទាប់នេះធានាថាទិន្នន័យត្រូវតែទទួលបានក្នុងលំដាប់ដូចគ្នាដែលវាត្រូវបានផ្ញើ។

- ស្រទាប់នេះផ្តល់នូវការដឹកជញ្ជូន end-to-end នៃទិន្នន័យរវាងម៉ាស៊ីនដែលអាចនឹងមិនស្ថិតនៅក្នុងបណ្តាញតែមួយ។

- រាល់ដំណើរការ server ត្រូវទំនាក់ទំនងតាមបណ្តាញដោយប្រើ Transport Service Access Points (TSAPs) ដែលស្គាល់ថាជាលេខ port។

# End-to-End Communication
---
ដំណើរការនៅក្នុង host មួយអាចទំនាក់ទំនងជាមួយ host ផ្សេងទៀតតាមរយៈ TSAPs។ ដំណើរការនីមួយៗត្រូវបានកំណត់យ៉ាងច្បាស់លាស់ ហើយដំណើរការដែលព្យាយាមទំនាក់ទំនងជាមួយវាត្រូវដឹងជាមុន។

![[Pasted image 20250201205204.png]]

ឧទាហរណ៍ នៅពេលដែល DHCP client ចង់ទំនាក់ទំនងជាមួយ remote DHCP server វាត្រូវបានកំណត់ដោយប្រើ port number 67។ នៅពេល DHCP client ចង់ទំនាក់ទំនងជាមួយ remote DNS server វាតែងតែប្រើ port number 53 (UDP)។

ពិធីការ Transport layer សំខាន់ៗមានពីរគឺ៖

1. **Transmission Control Protocol**
វាផ្តល់នូវការទំនាក់ទំនងដែលអាចជឿទុកចិត្តបានរវាង hosts។

2. **User Datagram Protocol**
វាផ្តល់នូវការទំនាក់ទំនងដែលមិនអាចជឿទុកចិត្តបានរវាង hosts។

# **23. TRANSMISSION CONTROL PROTOCOL**

TCP គឺជាពិធីការមួយក្នុងចំណោមពិធីការសំខាន់ៗបំផុតនៃ Internet Protocols។ វាជាពិធីការដែលត្រូវបានប្រើប្រាស់យ៉ាងទូលំទូលាយសម្រាប់ការបញ្ជូនទិន្នន័យក្នុងបណ្តាញទំនាក់ទំនងដូចជា Internet។

# Features
---
- TCP គឺជាពិធីការដែលអាចទុកចិត្តបាន។ មានន័យថា អ្នកទទួលតែងតែផ្ញើការបញ្ជាក់វិជ្ជមាន ឬ អវិជ្ជមានអំពីកញ្ចប់ទិន្នន័យទៅកាន់អ្នកផ្ញើ ដូច្នេះអ្នកផ្ញើតែងតែដឹងច្បាស់ថាតើកញ្ចប់ទិន្នន័យបានទៅដល់គោលដៅឬត្រូវផ្ញើម្តងទៀត។

- TCP ធានាថាទិន្នន័យទៅដល់គោលដៅដែលចង់បានតាមលំដាប់លំដោយដែលវាត្រូវបានផ្ញើ។

- TCP ផ្តោតលើការតភ្ជាប់។ TCP តម្រូវឱ្យមានការតភ្ជាប់រវាងចំណុចចម្ងាយពីរត្រូវបានបង្កើតឡើងមុនពេលផ្ញើទិន្នន័យជាក់ស្តែង។

- TCP ផ្តល់នូវយន្តការត្រួតពិនិត្យកំហុស និងការស្តារឡើងវិញ។

- TCP ផ្តល់នូវការទំនាក់ទំនងពីចុងដល់ចុង។

- TCP ផ្តល់នូវការគ្រប់គ្រងលំហូរ និងគុណភាពសេវាកម្ម។

- TCP ដំណើរការក្នុងទម្រង់ Client/Server ពីចំណុចទៅចំណុច។

- TCP ផ្តល់នូវម៉ាស៊ីនបម្រើ full duplex មានន័យថាវាអាចបំពេញតួនាទីទាំងអ្នកទទួល និងអ្នកផ្ញើ។

# Header
---
ប្រវែងនៃ TCP header គឺអប្បបរមា 20 bytes និងអតិបរមា 60 bytes។

![[Pasted image 20250201205540.png]]

- **Source Port (16-bits)**: វាកំណត់អត្តសញ្ញាណ port នៃដំណើរការកម្មវិធីនៅលើឧបករណ៍ផ្ញើ។

- **Destination Port (16-bits)**: វាកំណត់អត្តសញ្ញាណ port នៃដំណើរការកម្មវិធីនៅលើឧបករណ៍ទទួល។

- **Sequence Number (32-bits)**: លេខលំដាប់នៃបៃទិន្នន័យក្នុង segment ក្នុងវគ្គមួយ។

- **Acknowledgement Number (32-bits)**: នៅពេល ACK flag ត្រូវបានកំណត់ លេខនេះមានលេខលំដាប់បន្ទាប់នៃបៃទិន្នន័យដែលរំពឹងទុក និងដំណើរការជាការទទួលស្គាល់ទិន្នន័យមុនដែលបានទទួល។

* **Data Offset (4-bits)**: វាលនេះបង្ហាញពីទំហំ TCP header (32-bit words) និងការប្តូរទីតាំងទិន្នន័យនៅក្នុងកញ្ចប់ TCP បច្ចុប្បន្ន។

-  **Reserved (3-bits)**: ទុកសម្រាប់ប្រើប្រាស់នាពេលអនាគត ហើយត្រូវបានកំណត់ទៅជាសូន្យតាមលំនាំដើម។

-  **Flags (1-bit each)**:

	-  **NS**៖ Nonce Sum bit ត្រូវបានប្រើដោយ Explicit Congestion Notification signaling process។

	- **CWR**៖ នៅពេលម៉ាស៊ីនទទួលបានកញ្ចប់ដែលមាន ECE bit កំណត់ វាកំណត់ Congestion Windows Reduced ដើម្បីទទួលស្គាល់ថា ECE បានទទួល។

	- **ECE**៖ វាមានអត្ថន័យពីរ៖
		  - បើ SYN bit កំណត់ទៅ 0 នោះ ECE មានន័យថា IP packet មាន CE (congestion experience) bit កំណត់។
		  - បើ SYN bit កំណត់ទៅ 1 នោះ ECE មានន័យថាឧបករណ៍គឺ ECT capable។

	- **URG**: វាបង្ហាញថា Urgent Pointer field មានទិន្នន័យសំខាន់និងគួរតែត្រូវបានដំណើរការ។

	- **ACK**: វាបង្ហាញថា Acknowledgement field មានសារៈសំខាន់។ បើ ACK ត្រូវបានសម្អាតទៅ 0 វាបង្ហាញថាកញ្ចប់មិនមានការទទួលស្គាល់។

	- **PSH**: នៅពេលកំណត់ វាជាសំណើទៅកាន់ស្ថានីយ៍ទទួលដើម្បី PUSH ទិន្នន័យភ្លាមៗនៅពេលវាមកដល់កម្មវិធីទទួលដោយមិនចាំបាច់ buffer វា។

	- **RST**: Reset flag មានលក្ខណៈដូចខាងក្រោម៖
		  - វាត្រូវបានប្រើដើម្បីបដិសេធការតភ្ជាប់ដែលកំពុងចូល។
		  - វាត្រូវបានប្រើដើម្បីបដិសេធ segment មួយ។
		  - វាត្រូវបានប្រើដើម្បីចាប់ផ្តើមការតភ្ជាប់ឡើងវិញ។

	- **SYN**: ទង់នេះត្រូវបានប្រើដើម្បីបង្កើតការតភ្ជាប់រវាងម៉ាស៊ីន។

	- **FIN**: ទង់នេះត្រូវបានប្រើដើម្បីបញ្ចប់ការតភ្ជាប់ហើយគ្មានទិន្នន័យត្រូវបានផ្លាស់ប្តូរបន្ទាប់ពីនេះទៀតទេ។ ដោយសារកញ្ចប់ជាមួយទង់ SYN និង FIN មានលេខលំដាប់ ពួកវាត្រូវបានដំណើរការតាមលំដាប់ត្រឹមត្រូវ។

- Windows Size: វាលនេះត្រូវបានប្រើសម្រាប់ការគ្រប់គ្រងលំហូររវាងស្ថានីយ៍ពីរ និងបង្ហាញពីបរិមាណ buffer (គិតជា bytes) ដែលអ្នកទទួលបានបម្រុងទុកសម្រាប់ segment មួយ។

- Checksum: វាលនេះមាន checksum នៃ Header, Data និង Pseudo Headers។

-  Urgent Pointer: វាចង្អុលទៅកាន់ byte ទិន្នន័យបន្ទាន់បើទង់ URG ត្រូវបានកំណត់ទៅ 1។

- Options: វាសម្រួលដល់ជម្រើសបន្ថែមដែលមិនត្រូវបានគ្របដណ្តប់ដោយ header ធម្មតា។ វាល Option ត្រូវបានពណ៌នាជានិច្ចក្នុង 32-bit words។ បើវាលនេះមានទិន្នន័យតិចជាង 32-bit ការបំពេញត្រូវបានប្រើដើម្បីគ្របដណ្តប់ bits ដែលនៅសល់ដើម្បីឈានដល់ព្រំដែន 32-bit។

# Addressing
---
ការទំនាក់ទំនង TCP រវាងម៉ាស៊ីនចម្ងាយពីរត្រូវបានធ្វើឡើងតាមរយៈលេខច្រក (TSAPs)។ លេខច្រកមានចន្លោះពី 0 - 65535 ដែលត្រូវបានបែងចែកជា៖
- System Ports (0 - 1023)
- User Ports (1024 - 49151)
- Private/Dynamic Ports (49152 - 65535)

# Connection Management
---
ការទំនាក់ទំនង TCP ដំណើរការក្នុងម៉ូដែល Server/Client។ client ផ្តើមការតភ្ជាប់ហើយ server ទទួលយកឬបដិសេធវា។ Three-way handshaking ត្រូវបានប្រើសម្រាប់ការគ្រប់គ្រងការតភ្ជាប់។

![[Pasted image 20250201210319.png]]

## Establishment
Client ចាប់ផ្តើមការតភ្ជាប់ និងផ្ញើ segment ជាមួយនឹងលេខ Sequence។ Server ឆ្លើយតបត្រឡប់មកវិញជាមួយនឹងលេខ Sequence របស់ខ្លួន និង ACK នៃ segment របស់ Client ដែលមានលេខច្រើនជាងលេខ Sequence របស់ Client មួយ។ Client បន្ទាប់ពីទទួលបាន ACK នៃ segment របស់ខ្លួន នឹងផ្ញើការទទួលស្គាល់នៃការឆ្លើយតបរបស់ Server។

## Release
Server ឬ Client អាចផ្ញើ TCP segment ជាមួយនឹង FIN flag កំណត់ទៅជា 1។ នៅពេលដែលភាគីទទួលឆ្លើយតបវិញដោយផ្ញើ ACK ទៅ FIN នោះទិសដៅនៃការទំនាក់ទំនង TCP ត្រូវបានបិទ និងការតភ្ជាប់ត្រូវបានបញ្ចប់។

## Bandwidth Management
TCP ប្រើប្រាស់គោលការណ៍នៃ window size ដើម្បីសម្របសម្រួលតម្រូវការនៃការគ្រប់គ្រងតម្រូវការបណ្តាញ។ Window size គឺជាចំនួនទិន្នន័យជា byte ដែលអ្នកផ្ញើនៅចុងបញ្ចប់អាចផ្ញើ និងចំនួនទិន្នន័យជា byte segments ដែលអ្នកទទួលអាចទទួលបាននៅពេលនោះ។ TCP ប្រើដំណាក់កាលចាប់ផ្តើមយឺតដោយប្រើ window size 1 និងបង្កើន window size ជាទ្វេដងបន្ទាប់ពីការទំនាក់ទំនងជោគជ័យនីមួយៗ។

ឧទាហរណ៍៖ client ប្រើ windows size 2 និងផ្ញើទិន្នន័យ 2 bytes។ នៅពេលទទួលបានការទទួលស្គាល់នៃ segment នេះ windows size ត្រូវបានបង្កើនទ្វេដងទៅ 4 និងបន្ទាប់មក...

ចំណែកដែលផ្ញើនឹងមាន data bytes ចំនួន ៤។ នៅពេលដែល acknowledgement នៃ ៤-byte data segment ត្រូវបានទទួល window size នឹងកើនឡើងដល់ ៨ និងបន្តទៅទៀត។

ប្រសិនបើ acknowledgement បាត់បង់ មានន័យថាទិន្នន័យបាត់បង់នៅក្នុងបណ្តាញ ឬទទួលបាន NACK នោះ window size នឹងត្រូវកាត់បន្ថយពាក់កណ្តាល ហើយដំណាក់កាល slow start នឹងចាប់ផ្តើមឡើងវិញ។

# Error Control and Flow Control
---
TCP ប្រើប្រាស់ port numbers ដើម្បីដឹងថាវាត្រូវបញ្ជូនទិន្នន័យទៅកាន់ដំណើរការកម្មវិធីណាមួយ។ ជាមួយនឹងការនេះ sequence numbers ត្រូវបានប្រើដើម្បីធ្វើសមកាលកម្មជាមួយ remote host។ រាល់ data segments ទាំងអស់ត្រូវបានផ្ញើនិងទទួលជាមួយនឹង sequence numbers។ Sender ដឹងថា data segment ណាមួយត្រូវបានទទួលដោយ receiver នៅពេលដែលវាទទួលបាន ACK។ Receiver ដឹងអំពី last segment ដែលបានផ្ញើដោយ sender ដោយយោងទៅលេខ sequence នៃកញ្ចប់ដែលទើបទទួលបាន។

ប្រសិនបើលេខ sequence នៃកញ្ចប់ដែលទើបទទួលបានមិនត្រូវគ្នាជាមួយនឹងលេខ sequence ដែល receiver រំពឹងទុក នោះវានឹងត្រូវបោះបង់ចោល ហើយ NACK នឹងត្រូវផ្ញើត្រឡប់ទៅវិញ។ ប្រសិនបើកញ្ចប់ពីរមកដល់ជាមួយនឹងលេខ sequence ដូចគ្នា TCP timestamp នឹងត្រូវបានប្រើប្រាស់ដើម្បីធ្វើការសម្រេចចិត្ត។

# Multiplexing
---
បច្ចេកទេសក្នុងការបញ្ចូល data streams ពីរឬច្រើនក្នុងមួយ session ត្រូវបានហៅថា Multiplexing។ នៅពេលដែល TCP client ចាប់ផ្តើមការតភ្ជាប់ជាមួយ Server វាតែងតែយោងទៅ well-defined port number ដែលបង្ហាញពីដំណើរការកម្មវិធី។ TCP client ប្រើប្រាស់លេខ port ចៃដន្យពី private port number pools។

ការប្រើប្រាស់ TCP Multiplexing កម្មវិធីអាចទំនាក់ទំនងជាមួយនឹងដំណើរការកម្មវិធីផ្សេងៗគ្នាជាច្រើនក្នុងមួយ session។ ឧទាហរណ៍ អតិថិជនស្នើសុំ web page ដែលបន្ទាប់មកបង្កើតការស្នើសុំផ្សេងៗគ្នានៃទិន្នន័យ (HTTP, SMTP, FTP ។ល។) TCP session timeout ត្រូវបានបង្កើន ហើយ session ត្រូវបានរក្សាទុកឱ្យបើកយូរជាងមុនដើម្បីឱ្យការចាប់ដៃបីដងអាចត្រូវបានជៀសវាង។

នេះអនុញ្ញាតឱ្យប្រព័ន្ធអតិថិជនទទួលបានការតភ្ជាប់ច្រើនលើការតភ្ជាប់និម្មិតតែមួយ។ ការតភ្ជាប់និម្មិតទាំងនេះមិនល្អសម្រាប់ Servers ទេប្រសិនបើវាបើកទុកយូរពេក។

# Congestion Control
---
នៅពេលដែលបរិមាណទិន្នន័យដែលបញ្ចូលទៅក្នុងប្រព័ន្ធលើសពីសមត្ថភាពដែលអាចដំណើរការបាន congestion កើតឡើង។ TCP គ្រប់គ្រងការកកស្ទះតាមរយៈយន្តការ Window mechanism។ TCP កំណត់ window size ដែលប្រាប់ភាគីម្ខាងទៀតថាត្រូវផ្ញើ data segment ប៉ុន្មាន។ TCP មានអាល់ករីតឹមសម្រាប់ congestion ដែលមាន៖

- Additive increase, Multiplicative Decrease
- Slow Start
- Timeout React

# Timer Management
---
TCP ប្រើប្រាស់ Timer ផ្សេងៗគ្នាដើម្បីត្រួតពិនិត្យ និងគ្រប់គ្រងកិច្ចការផ្សេងៗ៖

## Keep-alive timer:
- Timer នេះត្រូវបានប្រើដើម្បីពិនិត្យមើលភាពត្រឹមត្រូវ និងសុពលភាពនៃការតភ្ជាប់។
- នៅពេលដែល keep-alive time អស់សុពលភាព host នឹងផ្ញើ probe ដើម្បីពិនិត្យមើលថាតើការតភ្ជាប់នៅមានដែរឬទេ។

## Retransmission timer:
- Timer នេះរក្សាទុកនូវ stateful session នៃទិន្នន័យដែលបានផ្ញើ។
- ប្រសិនបើការទទួលស្គាល់នៃទិន្នន័យដែលបានផ្ញើមិនទទួលបានក្នុងរយៈពេល Retransmission time ទិន្នន័យនោះនឹងត្រូវផ្ញើម្តងទៀត។

## Persist timer:
- TCP session អាចត្រូវបានផ្អាកដោយ host ណាមួយដោយការផ្ញើ Window Size 0។
- ដើម្បីបន្ត session host ត្រូវផ្ញើ Window Size ជាមួយនឹងតម្លៃធំជាងមុន។
- ប្រសិនបើ segment មិនដល់ចុងម្ខាងទៀត ចុងទាំងពីរអាចរង់ចាំគ្នាទៅវិញទៅមកដោយគ្មានពេលកំណត់។
- នៅពេល Persist timer អស់សុពលភាព host នឹងផ្ញើ window size របស់ខ្លួនម្តងទៀតដើម្បីឱ្យចុងម្ខាងទៀតដឹង។
- Persist Timer ជួយជៀសវាង deadlocks ក្នុងការទំនាក់ទំនង។

## Timed-Wait:
- បន្ទាប់ពីបញ្ចប់ការតភ្ជាប់ host ណាមួយនឹងរង់ចាំរយៈពេល Timed-Wait ដើម្បីបញ្ចប់ការតភ្ជាប់ឱ្យបានពេញលេញ។
- នេះគឺដើម្បីធានាថាចុងម្ខាងទៀតបានទទួលការទទួលស្គាល់នៃសំណើបញ្ចប់ការតភ្ជាប់របស់ខ្លួន។
- Timed-out អាចមានរយៈពេលអតិបរមា 240 វិនាទី (4 នាទី)។

# Crash Recovery
---
TCP គឺជា reliable protocol។ វាផ្តល់នូវលេខលំដាប់ទៅឱ្យ byte នីមួយៗដែលបានផ្ញើក្នុង segment។ វាផ្តល់នូវយន្តការ feedback ពោលគឺនៅពេល host ទទួលបាន packet វាត្រូវតែឆ្លើយតបទៅ host ដែលផ្ញើជាមួយនឹងលេខលំដាប់បន្ទាប់ដែលរំពឹងទុក (ប្រសិនបើវាមិនមែនជា last segment)។

នៅពេលដែល TCP Server ដាច់ការតភ្ជាប់ពាក់កណ្តាលនៃការទំនាក់ទំនង និងចាប់ផ្តើមដំណើរការឡើងវិញ វានឹងផ្ញើ TPDU broadcast ទៅកាន់ hosts ទាំងអស់របស់វា។ បន្ទាប់មក hosts ទាំងនោះអាចផ្ញើ data segment ចុងក្រោយដែលមិនទាន់បានទទួលស្គាល់ និងបន្តដំណើរការទៅមុខទៀត។

# **24. USER DATAGRAM PROTOCOL**

UDP (User Datagram Protocol) គឺជាពិធីការទំនាក់ទំនង Transport Layer ដែលសាមញ្ញបំផុត បើប្រៀបធៀបទៅនឹង TCP/IP។ វាផ្តល់នូវយន្តការទំនាក់ទំនងដែលមានទំហំតូចបំផុត។ UDP ត្រូវបានគេហៅថាជាពិធីការដឹកជញ្ជូនដែលមិនអាចជឿទុកចិត្តបាន ប៉ុន្តែវាប្រើសេវាកម្ម IP ដែលផ្តល់នូវយន្តការដឹកជញ្ជូនតាមការខិតខំប្រឹងប្រែងល្អបំផុត។

នៅក្នុង UDP អ្នកទទួលមិនបង្កើតការបញ្ជាក់ទទួលកញ្ចប់ទិន្នន័យទេ ហើយម្យ៉ាងវិញទៀត អ្នកផ្ញើមិនរង់ចាំការបញ្ជាក់ទទួលកញ្ចប់ទិន្នន័យដែលបានផ្ញើដែរ។ នេះធ្វើឱ្យពិធីការនេះមិនអាចជឿទុកចិត្តបាន ប៉ុន្តែងាយស្រួលក្នុងការដំណើរការ។

# Requirement of UDP
---
សំណួរមួយអាចកើតឡើង ហេតុអ្វីយើងត្រូវការពិធីការដែលមិនអាចជឿទុកចិត្តបានដើម្បីដឹកជញ្ជូនទិន្នន័យ? យើងប្រើ UDP ព្រោះកញ្ចប់ទិន្នន័យបញ្ជាក់ការទទួលបានបន្ថែមបន្ទុកផ្សេងៗនៃ bandwidth ជាមួយនឹងទិន្នន័យពិតប្រាកដ។ ឧទាហរណ៍ ក្នុងករណីនៃការស្ទ្រីមវីដេអូ ការបញ្ជាក់ទទួលកញ្ចប់ទិន្នន័យទាំងអស់គឺចំណាយពេលច្រើន និងអាចមានការខ្ជះខ្ជាយ bandwidth ច្រើន។ យន្តការដឹកជញ្ជូនល្អបំផុតនៃពិធីការ IP ធានានូវការខិតខំប្រឹងប្រែងល្អបំផុតក្នុងការដឹកជញ្ជូនកញ្ចប់ទិន្នន័យរបស់វា ប៉ុន្តែប្រសិនបើកញ្ចប់ទិន្នន័យមួយចំនួនក្នុងការស្ទ្រីមវីដេអូបាត់បង់ ផលប៉ះពាល់មិនធ្ងន់ធ្ងរទេ ហើយអាចមិនចាំបាច់យកចិត្តទុកដាក់។ ការបាត់បង់កញ្ចប់ទិន្នន័យមួយចំនួនក្នុងចរាចរណ៍វីដេអូ និងសំឡេងពេលខ្លះមិនសូវមានការកត់សម្គាល់ទេ។

# Features
---
- UDP ត្រូវបានប្រើនៅពេលដែលការបញ្ជាក់ទទួលទិន្នន័យមិនមានសារៈសំខាន់។
- UDP គឺជាពិធីការល្អសម្រាប់លំហូរទិន្នន័យក្នុងទិសដៅតែមួយ។
- UDP មានភាពសាមញ្ញ និងសមស្របសម្រាប់ការទំនាក់ទំនងផ្អែកលើការសាកសួរ។
- UDP មិនមែនជាការតភ្ជាប់ដោយផ្ទាល់ទេ។
- UDP មិនផ្តល់យន្តការគ្រប់គ្រងការកកស្ទះទេ។
- UDP មិនធានាការដឹកជញ្ជូនទិន្នន័យតាមលំដាប់លំដោយទេ។
- UDP គ្មានស្ថានភាព។
- UDP គឺជាពិធីការដែលសមស្របសម្រាប់កម្មវិធីស្ទ្រីមដូចជា VoIP និងការស្ទ្រីមពហុមេឌៀ។

# UDP Header
---
UDP header មានភាពសាមញ្ញដូចមុខងាររបស់វាដែរ។

![[Pasted image 20250201211257.png]]

UDP header មានប៉ារ៉ាម៉ែត្រសំខាន់ៗចំនួនបួន:

1. **Source Port**: ព័ត៌មាន ១៦ bits នេះត្រូវបានប្រើដើម្បីកំណត់អត្តសញ្ញាណ source port នៃ packet។

2. **Destination Port**: ព័ត៌មាន ១៦ bits នេះត្រូវបានប្រើដើម្បីកំណត់អត្តសញ្ញាណសេវាកម្មកម្រិត application នៅលើម៉ាស៊ីនគោលដៅ។

3. **Length**: វាលប្រវែងបញ្ជាក់ពីប្រវែងសរុបនៃ UDP packet (រួមទាំង header)។ វាជាវាល ១៦-bits ហើយតម្លៃអប្បបរមាគឺ ៨-byte ពោលគឺទំហំនៃ UDP header ខ្លួនឯង។

4. **Checksum**: វាលនេះផ្ទុកតម្លៃ checksum ដែលបង្កើតដោយអ្នកផ្ញើមុនពេលផ្ញើ។ IPv4 មានវាលនេះជាជម្រើស ដូច្នេះនៅពេលវាល checksum មិនមានតម្លៃ វាត្រូវបានធ្វើឱ្យស្មើសូន្យ និងប៊ីតទាំងអស់របស់វាត្រូវបានកំណត់ទៅជាសូន្យ។

# UDP application
---
ខាងក្រោមនេះគឺជាកម្មវិធីមួយចំនួនដែល UDP ត្រូវបានប្រើប្រាស់ដើម្បីបញ្ជូនទិន្នន័យ:

- Domain Name Services
- Simple Network Management Protocol
- Trivial File Transfer Protocol
- Routing Information Protocol
- Kerberos

# **25. APPLICATION LAYER INTRODUCTION**

Application Layer គឺជាស្រទាប់លើគេបង្អស់នៅក្នុងម៉ូដែល OSI និង TCP/IP។ ស្រទាប់នេះមានទាំងនៅក្នុង Layered Models ដោយសារតែសារៈសំខាន់នៃការប្រាស្រ័យទាក់ទងជាមួយនឹងអ្នកប្រើប្រាស់និងកម្មវិធី។ ស្រទាប់នេះគឺសម្រាប់កម្មវិធីដែលពាក់ព័ន្ធក្នុងប្រព័ន្ធទំនាក់ទំនង។

អ្នកប្រើប្រាស់អាច ឬមិនអាចធ្វើអន្តរកម្មដោយផ្ទាល់ជាមួយ applications។ Application layer គឺជាកម្រិតដែលការទំនាក់ទំនងពិតប្រាកដត្រូវបានចាប់ផ្តើម និងឆ្លុះបញ្ចាំង។ ដោយសារកម្រិតនេះស្ថិតនៅផ្នែកខាងលើនៃ layer stack វាមិនបម្រើកម្រិតផ្សេងទៀតឡើយ។ Application layer ត្រូវការជំនួយពី Transport និងគ្រប់កម្រិតទាំងអស់ដែលនៅខាងក្រោមវា ដើម្បីទំនាក់ទំនង ឬផ្ទេរទិន្នន័យរបស់វាទៅកាន់ remote host។

នៅពេលដែលកម្មវិធីណាមួយចង់ធ្វើការទំនាក់ទំនងជាមួយនឹងកម្មវិធីផ្សេងទៀតនៅលើម៉ាស៊ីនផ្សេង វាត្រូវផ្ញើទិន្នន័យឬព័ត៌មានទៅកាន់ Transport Layer។ ដោយសារស្រទាប់នេះស្ថិតនៅផ្នែកខាងលើនៃ layer stack វាមិនបម្រើស្រទាប់ផ្សេងទៀតឡើយ។ កម្មវិធីត្រូវការជំនួយពី Transport និងស្រទាប់ផ្សេងៗខាងក្រោមដើម្បីទំនាក់ទំនងឬផ្ទេរទិន្នន័យទៅកាន់ម៉ាស៊ីនចុងគ្រា។

![[Pasted image 20250201211629.png]]

មានភាពស្រពិចស្រពិលក្នុងការយល់ដឹងអំពី Application Layer និង protocol របស់វា។ មិនមែនគ្រប់កម្មវិធីទាំងអស់សុទ្ធតែអាចដាក់បញ្ចូលទៅក្នុង Application Layer លើកលែងតែកម្មវិធីទាំងឡាយណាដែលធ្វើអន្តរកម្មជាមួយប្រព័ន្ធទំនាក់ទំនង។ ឧទាហរណ៍ ការរចនាកម្មវិធីឬកម្មវិធីកែសម្រួលអត្ថបទមិនអាចចាត់ទុកជាកម្មវិធី application layer បានទេ។

ម្យ៉ាងវិញទៀត នៅពេលយើងប្រើ Web Browser ដែលជាទូទៅប្រើ Hyper Text Transfer Protocol (HTTP) ដើម្បីធ្វើអន្តរកម្មជាមួយនឹង Web Server នោះ HTTP គឺជា Application Layer Protocol។

ឧទាហរណ៍មួយទៀតគឺ File Transfer Protocol ដែលជួយឱ្យអ្នកប្រើប្រាស់អាចផ្ទេរឯកសារជាអត្ថបទពីម៉ាស៊ីនមួយទៅម៉ាស៊ីនមួយទៀតតាមបណ្តាញ។ អ្នកប្រើប្រាស់អាចប្រើ protocol នេះក្នុងកម្មវិធី GUI ដូចជា FileZilla ឬ CuteFTP ហើយអ្នកប្រើប្រាស់ដដែលអាចប្រើ FTP នៅក្នុង Command Line mode។

ដូច្នេះ មិនថាអ្នកប្រើប្រាស់កម្មវិធីមួយណានោះទេ វាគឺជា protocol ដែលត្រូវបានចាត់ទុកថាជា Application Layer Protocol។ កម្មវិធីគ្រាន់តែជាឧបករណ៍ដែលជួយអ្នកប្រើប្រាស់សម្រេចការងារដែល application protocols ដូចជា HTTP ត្រូវបំពេញប៉ុណ្ណោះ។

# **26. CLIENT-SERVER MODEL**

ដំណើរការកម្មវិធីពីចម្ងាយពីរអាចទំនាក់ទំនងគ្នាបានជាចម្បងតាមរបៀបពីរផ្សេងគ្នា៖

-  **Peer-to-peer**: ដំណើរការពីចម្ងាយទាំងពីរកំពុងដំណើរការនៅកម្រិតដូចគ្នា ហើយពួកវាផ្លាស់ប្តូរទិន្នន័យដោយប្រើធនធានរួមគ្នា។

-  **Client-Server**: ដំណើរការពីចម្ងាយមួយដើរតួជា Client ហើយស្នើសុំធនធានពីដំណើរការកម្មវិធីមួយផ្សេងទៀតដែលដើរតួជា Server។

នៅក្នុងម៉ូដែល client-server ដំណើរការណាមួយអាចដើរតួជា Server ឬ Client។ វាមិនមែនជាប្រភេទនៃម៉ាស៊ីន ទំហំនៃម៉ាស៊ីន ឬថាមពលគណនារបស់វាដែលធ្វើឱ្យវាក្លាយជា server នោះទេ; វាគឺជាសមត្ថភាពក្នុងការបម្រើសំណើដែលធ្វើឱ្យម៉ាស៊ីនមួយក្លាយជា server។

![[Pasted image 20250201212024.png]]

ប្រព័ន្ធមួយអាចដើរតួជា Server និង Client ក្នុងពេលដំណាលគ្នា។ នោះគឺ ដំណើរការមួយកំពុងដើរតួជា Server ហើយដំណើរការមួយផ្សេងទៀតកំពុងដើរតួជា Client។ ករណីនេះអាចកើតឡើងនៅពេលដែលទាំងដំណើរការ client និង server ស្ថិតនៅលើម៉ាស៊ីនតែមួយ។

# Communication

ដំណើរការពីរក្នុងគំរូ client-server អាចធ្វើអន្តរកម្មតាមវិធីផ្សេងៗគ្នា៖
- Sockets
- Remote Procedure Calls (RPC)

## Sockets
ក្នុងគំរូនេះ ដំណើរការដែលដើរតួជា Server បើក socket ដោយប្រើ port ដែលស្គាល់ (ឬដែល client ស្គាល់) ហើយរង់ចាំរហូតដល់មានសំណើពី client។ ដំណើរការទីពីរដែលដើរតួជា Client ក៏បើក socket ដែរ ប៊ុន្តែជំនួសឱ្យការរង់ចាំសំណើចូល client ធ្វើការ "ស្នើសុំមុន"។

![[Pasted image 20250201212143.png]]

នៅពេលសំណើទៅដល់ server វានឹងត្រូវបានបម្រើ។ វាអាចជាការចែករំលែកព័ត៌មាន ឬសំណើធនធាន។

## Remote Procedure Call
នេះគឺជាយន្តការដែលដំណើរការមួយធ្វើអន្តរកម្មជាមួយដំណើរការមួយទៀតតាមរយៈការហៅ procedure។ ដំណើរការមួយ (client) ហៅ procedure ដែលស្ថិតនៅលើម៉ាស៊ីនពីចម្ងាយ។ ដំណើរការនៅលើម៉ាស៊ីនពីចម្ងាយត្រូវបានហៅថា Server។ ដំណើរការទាំងពីរត្រូវបានបែងចែក stubs។ ការទំនាក់ទំនងនេះកើតឡើងតាមរបៀបដូចខាងក្រោម៖

- ដំណើរការ client ហៅ client stub។ វាបញ្ជូនប៉ារ៉ាម៉ែត្រទាំងអស់ដែលទាក់ទងនឹងកម្មវិធីទៅកាន់វា។

- ប៉ារ៉ាម៉ែត្រទាំងអស់ត្រូវបានវេចខ្ចប់ (marshalled) ហើយ system call ត្រូវបានធ្វើឡើងដើម្បីផ្ញើពួកវាទៅកាន់ផ្នែកម្ខាងទៀតនៃបណ្តាញ។

- Kernel ផ្ញើទិន្នន័យតាមបណ្តាញ ហើយចុងម្ខាងទៀតទទួលវា។

- ពីចម្ងាយ host បញ្ជូនទិន្នន័យទៅ server stub ដែលនៅទីនោះវាត្រូវបាន unmarshalled។

- ប៉ារ៉ាម៉ែត្រត្រូវបានបញ្ជូនទៅកាន់ procedure ហើយ procedure ត្រូវបានប្រតិបត្តិ។

- លទ្ធផលត្រូវបានផ្ញើត្រឡប់ទៅ client វិញតាមរបៀបដូចគ្នា។

# **27. APPLICATION PROTOCOLS**

មានពិធីការជាច្រើនដែលដំណើរការសម្រាប់អ្នកប្រើប្រាស់នៅក្នុង Application Layer។ ពិធីការ Application layer អាចត្រូវបានបែងចែកជាទូទៅជាពីរប្រភេទ៖

- ពិធីការដែលត្រូវបានប្រើដោយអ្នកប្រើប្រាស់។ ឧទាហរណ៍ eMail។
- ពិធីការដែលជួយនិងគាំទ្រពិធីការដែលប្រើដោយអ្នកប្រើប្រាស់។ ឧទាហរណ៍ DNS។

ខាងក្រោមនេះគឺជាការពិពណ៌នាអំពីពិធីការ Application layer មួយចំនួន៖

# Domain Name System
---
Domain Name System (DNS) ដំណើរការលើម៉ូដែល Client-Server។ វាប្រើពិធីការ UDP សម្រាប់ការទំនាក់ទំនង transport layer។ DNS ប្រើប្រាស់ប្រព័ន្ធឈ្មោះផ្អែកលើដែន។ ម៉ាស៊ីនមេ DNS ត្រូវបានកំណត់រចនាសម្ព័ន្ធជាមួយ Fully Qualified Domain Names (FQDN) និងអាសយដ្ឋានអ៊ីមែលដែលត្រូវគ្នាជាមួយអាសយដ្ឋាន Internet Protocol របស់ពួកគេ។

ម៉ាស៊ីនមេ DNS ត្រូវបានស្នើសុំជាមួយ FQDN ហើយវាឆ្លើយតបវិញជាមួយអាសយដ្ឋាន IP។ វាប្រើ UDP port 53។

# Simple Mail Transfer Protocol
---
Simple Mail Transfer Protocol (SMTP) ត្រូវបានប្រើដើម្បីផ្ទេរសារអេឡិចត្រូនិកពីអ្នកប្រើប្រាស់ម្នាក់ទៅអ្នកប្រើប្រាស់ម្នាក់ទៀត។ កិច្ចការនេះត្រូវបានធ្វើឡើងតាមរយៈកម្មវិធីអ៊ីមែលអតិថិជន (User Agents)។ អ្នកប្រើប្រាស់កំពុងប្រើ User Agents ដើម្បីឱ្យអ្នកប្រើប្រាស់វាយបញ្ចូលនិងធ្វើទ្រង់ទ្រាយអ៊ីមែល និងផ្ញើវា នៅពេលដែលអ៊ីនធឺណិតមាន។ នៅពេលដែលអ៊ីមែលត្រូវបានដាក់ស្នើសុំដើម្បីផ្ញើ ដំណើរការផ្ញើត្រូវបានគ្រប់គ្រងដោយភ្នាក់ងារផ្ទេរសារ (Message Transfer Agent) ដែលរក្សាទុកអ៊ីមែលក្នុងជួរនៅក្នុងម៉ាស៊ីនមេ។

Message Transfer Agent ប្រើ SMTP ដើម្បីបញ្ជូនបន្តអ៊ីមែលទៅ Message Transfer Agent ផ្សេងទៀត។ ខណៈពេលដែល SMTP ត្រូវបានប្រើដោយអ្នកប្រើប្រាស់ដើម្បីផ្ញើតែអ៊ីមែល ម៉ាស៊ីនមេជាធម្មតាប្រើ SMTP ដើម្បីផ្ញើក៏ដូចជាទទួលអ៊ីមែលផងដែរ។ SMTP ប្រើ TCP port លេខ 25 និង 587។

កម្មវិធីអតិថិជនប្រើ Internet Message Access Protocol (IMAP) ឬ POP protocols ដើម្បីទទួលអ៊ីមែល។

# File Transfer Protocol
---
File Transfer Protocol (FTP) គឺជាពិធីការដែលត្រូវបានប្រើយ៉ាងទូលំទូលាយបំផុតសម្រាប់ការផ្ទេរឯកសារលើបណ្តាញ។ FTP ប្រើ TCP/IP សម្រាប់ការទំនាក់ទំនង ហើយវាដំណើរការលើ TCP port 21។ FTP ដំណើរការលើម៉ូដែល Client-Server ដែលអតិថិជនស្នើសុំធនធានពីម៉ាស៊ីនមេ ហើយម៉ាស៊ីនមេផ្ញើធនធានដែលបានស្នើសុំត្រឡប់ទៅអតិថិជនវិញ។

FTP ប្រើ port 20 សម្រាប់ការផ្លាស់ប្តូរព័ត៌មានគ្រប់គ្រង ហើយទិន្នន័យជាក់ស្តែងត្រូវបានផ្ញើតាម TCP port 21។

នៅពេលដែល client ស្នើសុំឯកសារមួយពី server នោះ server នឹងបើក TCP connection សម្រាប់ client និងផ្ទេរឯកសារនោះ។ បន្ទាប់ពីការផ្ទេរបានបញ្ចប់ server នឹងបិទការតភ្ជាប់។ សម្រាប់ឯកសារទីពីរ client ត្រូវស្នើសុំម្តងទៀតដោយបើក TCP connection ថ្មី។

# Post Office Protocol (POP)
---
Post Office Protocol (POP3) គឺជា protocol សាមញ្ញមួយសម្រាប់ការទាញយកសំបុត្រដែលត្រូវបានប្រើដោយ User Agents (កម្មវិធីអ៊ីមែលរបស់ client) ដើម្បីទាញយកសំបុត្រពី server។

នៅពេលដែល client ត្រូវការទាញយកសំបុត្រពី server វានឹងបង្កើតការតភ្ជាប់ជាមួយ server លើ port 110។ អ្នកប្រើប្រាស់អាចចូលប្រើសំបុត្រនិងទាញយកវាទៅក្នុងកុំព្យូទ័រផ្ទាល់ខ្លួន។ POP3 មានរបៀបពីរ។ របៀបទីមួយគឺលុបសំបុត្រចេញពី server បន្ទាប់ពីវាត្រូវបានទាញយកទៅកាន់ម៉ាស៊ីនក្នុងស្រុក។ របៀបទីពីរគឺ keep mode ដែលមិនលុបសំបុត្រចេញពី server និងផ្តល់ជម្រើសឱ្យអ្នកប្រើប្រាស់អាចចូលប្រើសំបុត្រនៅលើ mail server។

# Hyper Text Transfer Protocol (HTTP)
---
Hyper Text Transfer Protocol (HTTP) គឺជាកម្មវិធីដែលគាំទ្រ World Wide Web។ Hypertext គឺជាឯកសារដែលមានការរៀបចំល្អដែលប្រើ hyperlinks ដើម្បីភ្ជាប់អត្ថបទទៅអត្ថបទផ្សេងទៀត។ HTTP ដំណើរការលើ client server model។ នៅពេលអ្នកប្រើប្រាស់ចង់ចូលប្រើទំព័រ HTTP ណាមួយលើអ៊ីនធឺណិត ម៉ាស៊ីន client របស់អ្នកប្រើប្រាស់នឹងបង្កើត TCP connection ទៅកាន់ server លើ port 80។ នៅពេល server ទទួលយកសំណើនេះ client ត្រូវបានអនុញ្ញាតឱ្យចូលប្រើទំព័រ web។

ដើម្បីចូលប្រើទំព័រ web អ្នកប្រើប្រាស់ជាធម្មតាប្រើ web browsers ដែលទទួលខុសត្រូវក្នុងការបើក រក្សា និងបិទ TCP connections។ HTTP គឺជា stateless protocol ដែលមានន័យថា Server រក្សាទុកព័ត៌មានអំពីសំណើមុនៗរបស់ clients។

HTTP versions:
- HTTP 1.0 ប្រើ non-persistent HTTP។ វត្ថុភាគច្រើនត្រូវបានផ្ញើតាម single TCP connection។
- HTTP 1.1 ប្រើ persistent HTTP។ ក្នុងកំណែនេះ multiple objects អាចត្រូវបានផ្ញើតាម single TCP connection។

# **28. NETWORK SERVICES**

ប្រព័ន្ធកុំព្យូទ័រ និងប្រព័ន្ធដែលប្រើប្រាស់កុំព្យូទ័រ ជួយឱ្យមនុស្សធ្វើការងារប្រកបដោយប្រសិទ្ធភាព និងស្វែងរកអ្វីដែលមិនអាចស្វែងរកបាន។ នៅពេលដែលឧបករណ៍ទាំងនេះត្រូវបានតភ្ជាប់គ្នាជា network សមត្ថភាពត្រូវបានបង្កើនឡើងច្រើនដង។ សេវាកម្មមូលដ្ឋានមួយចំនួនដែល computer network អាចផ្តល់ជូនមានដូចជា៖

# Directory Services
---
សេវាកម្មទាំងនេះគឺជាការផ្គូផ្គងរវាង name និង value ដែលអាចជាតម្លៃអថេរ ឬថេរ។ ប្រព័ន្ធកម្មវិធីនេះជួយក្នុងការរក្សាទុកព័ត៌មាន រៀបចំវា និងធ្វើឱ្យវិធីសាស្ត្រផ្សេងៗនៃការចូលប្រើមានភាពងាយស្រួល។

## Accounting
នៅក្នុងអង្គភាពមួយ អ្នកប្រើប្រាស់ជាច្រើនមាន user names និង passwords ផ្គូផ្គងជាមួយពួកគេ។ Directory Services ផ្តល់នូវមធ្យោបាយនៃការរក្សាទុកព័ត៌មាននេះក្នុងទម្រង់ cryptic និងធ្វើឱ្យវាអាចប្រើប្រាស់បាននៅពេលស្នើសុំ។

## Authentication and Authorization
User credentials ត្រូវបានត្រួតពិនិត្យដើម្បី authenticate អ្នកប្រើប្រាស់នៅពេលចូល និង/ឬនៅពេលប្រើប្រាស់។ User accounts អាចត្រូវបានផ្តល់សិទ្ធិ និងការចូលប្រើធនធានរបស់ពួកគេអាចត្រូវបានគ្រប់គ្រងដោយប្រើប្រាស់ authorization schemes។

## Domain Name Services
DNS គឺត្រូវបានប្រើប្រាស់យ៉ាងទូលំទូលាយ និងជាសេវាកម្មសំខាន់មួយដែល internet ដំណើរការ។ ប្រព័ន្ធនេះផ្គូផ្គង IP addresses ទៅ domain names ដែលងាយស្រួលចងចាំ និងហៅជាងលេខ IP addresses។ ដោយសារ network ដំណើរការដោយជំនួយពី IP addresses និងមនុស្សចូលចិត្តចងចាំឈ្មោះគេហទំព័រ DNS ផ្តល់នូវ website's IP address ដែលត្រូវបានផ្គូផ្គងទៅនឹងឈ្មោះរបស់វាពីខាងក្រោយ និងតាមការស្នើសុំពីអ្នកប្រើប្រាស់។

# File Services
---
File services រួមមានការចែករំលែក និងផ្ទេរឯកសារនៅលើ network។

## File Sharing
មូលហេតុមួយក្នុងចំណោមមូលហេតុជាច្រើនដែលនាំឱ្យមាន networking គឺ file sharing។ ការចែករំលែកអនុញ្ញាតឱ្យអ្នកប្រើប្រាស់របស់វាចែករំលែកទិន្នន័យរបស់ពួកគេជាមួយអ្នកប្រើប្រាស់ផ្សេងទៀត។ អ្នកប្រើប្រាស់អាចផ្ទុកឯកសារទៅកាន់ file server ដែលអាចចូលប្រើបានដោយអ្នកប្រើប្រាស់ផ្សេងទៀត។ ជាជម្រើសមួយទៀត អ្នកប្រើប្រាស់អាចធ្វើឱ្យឯកសាររបស់គាត់ត្រូវបានចែករំលែកនៅលើកុំព្យូទ័រផ្ទាល់ខ្លួនរបស់គាត់ និងផ្តល់ការចូលប្រើដល់អ្នកប្រើប្រាស់ដែលមានបំណង។

## File Transfer
នេះគឺជាសកម្មភាពចម្លង ឬផ្លាស់ទីឯកសារពីកុំព្យូទ័រមួយទៅកុំព្យូទ័រមួយទៀត ឬទៅកុំព្យូទ័រច្រើន ដោយមានជំនួយពី network។ Network អនុញ្ញាតឱ្យអ្នកប្រើប្រាស់របស់វាអាចស្វែងរកអ្នកប្រើប្រាស់ផ្សេងទៀតនៅក្នុង network និងផ្ទេរឯកសារ។

# Communication Services
---
## Email
Electronic mail គឺជាវិធីសាស្ត្រទំនាក់ទំនង និងជាអ្វីដែលអ្នកប្រើប្រាស់កុំព្យូទ័រមិនអាចធ្វើការបានដោយគ្មានវា។ នេះគឺជាមូលដ្ឋានគ្រឹះនៃ internet features។ Email system មានមួយ ឬច្រើន email servers។ អ្នកប្រើប្រាស់ទាំងអស់ត្រូវបានផ្តល់ជូននូវ unique IDs។ នៅពេលអ្នកប្រើប្រាស់ផ្ញើ email ទៅអ្នកប្រើប្រាស់ផ្សេង វាត្រូវបានផ្ទេរជាក់ស្តែងរវាងអ្នកប្រើប្រាស់ដោយជំនួយពី email server។

## Social Networking
បច្ចេកវិទ្យាថ្មីៗបានធ្វើឱ្យវាមានលក្ខណៈបច្ចេកទេសតិចនិងសង្គមច្រើន។ អ្នកប្រើប្រាស់កុំព្យូទ័រដែលមានចំណេះដឹង អាចភ្ជាប់ទំនាក់ទំនងជាមួយមនុស្សផ្សេងទៀត មិត្តភក្តិ អាចភ្ជាប់ទំនាក់ទំនងជាមួយគ្នា ចែករំលែកគំនិត រូបភាព និងវីដេអូ។

## Internet Chat
Internet chat ផ្តល់នូវសេវាផ្ទេរភ្លាមៗរវាង hosts។ ពីរ ឬច្រើននាក់អាចទំនាក់ទំនងជាមួយគ្នាដោយប្រើ text-based Internet chat services។ សព្វថ្ងៃនេះ voice chat និង video chat មានភាពពេញនិយមខ្លាំងណាស់។

## Discussion Boards
Discussion boards ផ្តល់នូវយន្តការដើម្បីភ្ជាប់ទំនាក់ទំនងមនុស្សច្រើននាក់ដែលមានចំណាប់អារម្មណ៍ដូចគ្នា។ វាអនុញ្ញាតឱ្យអ្នកប្រើប្រាស់បង្ហោះសំណួរ យោបល់ សំណូមពរជាដើម ដែលអាចមើលឃើញដោយអ្នកប្រើប្រាស់ផ្សេងទៀតទាំងអស់។ អ្នកផ្សេងទៀតក៏អាចឆ្លើយតបផងដែរ។

## Remote Access
សេវាកម្មនេះអនុញ្ញាតឱ្យអ្នកប្រើប្រាស់អាចចូលប្រើប្រាស់ទិន្នន័យដែលស្ថិតនៅលើកុំព្យូទ័រពីចម្ងាយ។ មុខងារនេះត្រូវបានគេស្គាល់ថាជា Remote desktop។ នេះអាចធ្វើបានជាមួយឧបករណ៍ពីចម្ងាយមួយចំនួន ឧ.ទា. ទូរស័ព្ទចល័ត ឬកុំព្យូទ័រនៅផ្ទះ។

# Application Services
---
ទាំងនេះគឺគ្រាន់តែជាការផ្តល់សេវាកម្ម network ដល់អ្នកប្រើប្រាស់ដូចជា web services, database managing និង resource sharing។

## Resource Sharing
ដើម្បីប្រើប្រាស់ធនធានប្រកបដោយប្រសិទ្ធភាព និងសន្សំសំចៃ network ផ្តល់នូវមធ្យោបាយដើម្បីចែករំលែកពួកវា។ ទាំងនេះអាចរួមមាន Servers, Printers និង Storage Media ជាដើម។

## Databases
សេវាកម្ម application នេះគឺជាមួយក្នុងចំណោមសេវាកម្មសំខាន់បំផុត។ វារក្សាទុកទិន្នន័យ និងព័ត៌មាន ដំណើរការវា និងអនុញ្ញាតឱ្យអ្នកប្រើប្រាស់អាចទាញយកវាវិញដោយប្រើ queries។ Databases ជួយស្ថាប័ននានាក្នុងការធ្វើការសម្រេចចិត្តដោយផ្អែកលើស្ថិតិ។

## Web Services
World Wide Web គឺជាពាក្យដែលត្រូវបានប្រើប្រដូចទៅនឹង internet។ វាត្រូវបានប្រើប្រាស់ដើម្បីតភ្ជាប់ទៅកាន់ computer networks និងចូលប្រើប្រាស់ files និង information services ដែលផ្តល់ដោយ internet servers។